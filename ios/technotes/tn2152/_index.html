<!DOCTYPE html>
<html lang="en">
<head>
    <title>Technical Note TN2152: Document Transfer Strategies</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Technical Note">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/DTS40009179">
	<meta id="document-version" name="document-version" content="2.2.0">
    <meta id="build" name="build" content="bcf073e0579478458b78c3b3068a2133">
    <meta id="chapterId" name="chapterId" content="DTS40009179-CH1">
    <meta id="date" name="date" content="2010-07-26">
    <meta id="description" name="description" content="TN2152: Describes various strategies for device-to-device and device-to-computer document transfer.">
    <meta id="book-title" name="book-title" content="Document Transfer Strategies">
    <meta id="book-name" name="book-name" contents="DTS_TN2152_DocumentTransfer">
    <meta id="book-root" name="book-root" content="./">
    <meta id="book-json" name="book-json" content="book.json">
    <meta id="devcenter" name="devcenter" content="iOS Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/ios">
    <meta id="reflib" name="reflib" content="iOS Developer Library">
    <meta id="book-assignments" name="book-assignments" content="{Type/Technical Note}, {Topic/Networking & Internet}">
    
    
    <meta id="generator" name="generator" content="Gutenberg 003a3034">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2014 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Technical Note TN2152">
    <meta id="resources-uri" name="resources-uri" content="../../Resources/874">
    <link id="book-index-page" rel="Start" title="Document Transfer Strategies" type="text/html" href="index.html">
    <link id="next-page" rel="Next" type="text/html" href="">
    <link id="previous-page" rel="Prev" type="text/html" href="">
    <link rel="stylesheet" type="text/css" href="../../Resources/874/CSS/screen.css">
    
    <link rel="stylesheet" type="text/css" href="../../Resources/874/CSS/feedback.css">
</head>    
<body><a name="//apple_ref/doc/uid/DTS40009179" title="Technical Note TN2152"></a>
    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode phone">
            <a id="ssi_LibraryTitle" href='../../navigation/index.html'>iOS Developer Library</a>
            <a id="ssi_AppleDeveloperConnection" href='../../../../index.html'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search iOS Developer Library</label>
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Document Transfer Strategies</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main" class="dts_doc">
        <!-- CONTENTS -->
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_2" title="Technical Note TN2152"></a><div class="dtsDocNumber">Technical Note TN2152</div><h1 id="pageTitle">Document Transfer Strategies</h1><p>One of the questions most frequently asked by iOS developers is, how can I transfer data between my application running on the user's device and my application running on the user's computer. This technote describes the nature of the problem and outlines the various paths to a solution.</p><p>Primarily this technote addresses developers working on iOS. However, many of the techniques described herein apply equally well to Mac OS X, so even developers working exclusively on Mac OS X might find it interesting.</p>

   
    <div class="outerMiniTOC">

        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION1">Introduction</a>
                
                
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION2">Networking Problems With Common Solutions</a>
                
                
                
                    <div class="nestedMiniTOC">
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION2">Reliability</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION3">Bandwidth</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION4">Latency</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION5">Malicious Attack</a>
                            
                        </div>
                        
                    
                    </div>
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION7">Networking Problems With Architecture-Specific Solutions</a>
                
                
                
                    <div class="nestedMiniTOC">
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION7">Service Discovery</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION8">Authorization</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION9">On-The-Wire Privacy</a>
                            
                        </div>
                        
                    
                    </div>
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION11">On TLS</a>
                
                
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION12">Networking Designs</a>
                
                
                
                    <div class="nestedMiniTOC">
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION12">WWAN Link-Layer Issues</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION13">Wi-Fi Link Layer Issues</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION14">Bluetooth Link Layer Issues</a>
                            
                        </div>
                        
                    
                    </div>
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION16">Solutions For Centralized Server Designs</a>
                
                
                
                    <div class="nestedMiniTOC">
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION16">Service Discovery</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION17">Authorization</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION18">On-The-Wire Privacy</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION19">Renting Infrastructure</a>
                            
                        </div>
                        
                    
                    </div>
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION21">Solutions For Peer-To-Peer Designs</a>
                
                
                
                    <div class="nestedMiniTOC">
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION21">Service Discovery</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION22">Authorization</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION24">On-The-Wire Privacy</a>
                            
                        </div>
                        
                    
                        
                        <div>
                            <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION25">On GameKit</a>
                            
                        </div>
                        
                    
                    </div>
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION27">Protocol Issues</a>
                
                
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION28">File Transfer Protocols</a>
                
                
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-CH1-SECTION29">Syncing Issues</a>
                
                
                
            </div>
            
        
			
            <div>
                <a href="_index.html#/apple_ref/doc/uid/DTS40009179-RevisionHistory-DontLinkElementID_1">Document Revision History</a>
                
                
                
            </div>
            
        
    </div>

<section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION1" title="Introduction"></a><h2 class="jump">Introduction</h2><p>Many iOS applications need the ability to transfer data between the user's computer and their iOS device, or between two iOS devices. For example:</p><ul class="ul"><li class="li"><p>A PDF viewing application needs a way to get PDF files on to the device.</p></li><li class="li"><p>An iOS to-do list application that has a Mac OS X equivalent needs to sync to-do lists between the application running on the device and the application running on the Mac.</p></li><li class="li"><p>An iOS application with 'lite' and 'pro' versions needs to transfer data between these versions.</p></li><li class="li"><p>An iOS note-taking application needs to provide an easy way to backup and restore these notes, independently of the standard iTunes backup mechanism.</p></li></ul><p>Starting with iOS 3.2 on iPad, Apple introduced a file sharing technology (<code>UIFileSharingEnabled</code>) that allows an application to expose its Documents directory to the user through iTunes. The user can then move files back and forth between their device and their computer. Moreover, iOS 4 has brought this feature to both iPhone and iPod touch.</p><p>You can learn more about iTunes file sharing in the <span class="content_text"><a href="../../_releasenotes/General/WhatsNewIniPhoneOS/Articles/ios.html#/apple_ref/doc/uid/TP40009337-SW11" class="browserLink" >File-Sharing Support</a></span> section of <span class="content_text"><a href="../../_releasenotes/General/WhatsNewIniPhoneOS/Introduction/ios.html" class="browserLink" >What's New in iPhone OS</a></span>.</p><p>iTunes file sharing does not, however, solve all document transfer problems. For example:</p><ul class="ul"><li class="li"><p>It requires iOS 3.2 or later. If you must support older versions of iOS, file sharing is not an option.</p></li><li class="li"><p>It does not support device-to-device document transfers.</p></li><li class="li"><p>It is only supported over USB; the user has to plug in their device.</p></li></ul><p>In these circumstances it is necessary to implement your own transfer mechanism based on TCP/IP networking. If you're not familiar with network programming this can be a very daunting task. All network code must deal with certain hard problems, and if you're new to the field you may not even understand the problems, let alone know how to solve them.</p><p>The remainder of this document describes the problems you must solve, the  two standard designs you can use to address those problems and, within each design, the specific techniques you can use. There's an emphasis on Apple technologies, but you must keep in mind that, if you're targeting general iOS users, your user's computer may be a Windows PC.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_3" title="Note"></a><p><strong>Note:</strong>&nbsp;Much of the information in this document was presented at WWDC 2010 in the "Network Apps for iPhone OS" talk (part 1 and 2, sessions 207 and 208). If you prefer listening to reading, you should check out the <span class="content_text"><a href="../../../../videos/wwdc/2010/index.html" class="browserLink" >session videos</a></span>.</p><p></p></aside></div><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION2" title="Networking Problems With Common Solutions"></a><h2 class="jump">Networking Problems With Common Solutions</h2><p>Any networking code must deal with a certain set of fundamental problems. Some of these problems have solutions that apply regardless of your overall networking design. The following subsections describe these problems and their solutions.</p><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION2" title="Reliability"></a><h3 class="jump">Reliability</h3><p>The network may drop, delay, reorder, or corrupt the packets you send. Moreover, the entire network may come and go. All of these problems are more prevalent on mobile devices than on standard computers. Your application must handle all of these problems gracefully.</p><p>The weapon of choice here is TCP. When you open a TCP connection between two networked peers, you are guaranteed one of two results:</p><ul class="ul"><li class="li"><p>data you send will be transferred intact and in order, or </p></li><li class="li"><p>the connection will break</p></li></ul><p>TCP takes care of all the fiddly details required to make this work; unless you're a networking expert, you should avoid reinventing this particular wheel and use TCP, or some higher-level protocol layered on top of TCP, for your communications.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION3" title="Bandwidth"></a><h3 class="jump">Bandwidth</h3><p>Every network has a limit to the amount of data that you can move through the network per unit of time. <span class="content_text"><a href="http://en.wikipedia.org/wiki/Wireless_Wide_Area_Network" class="urlLink" rel="external">Wireless wide-area networks</a></span> (WWANs) present a serious bandwidth challenge; that is, the bandwidth of a WWAN is low compared to the typical data size of a modern application. You must keep this limitation in mind when designing your application.</p><p>There may also be non-technical aspects of the bandwidth problem. Many iPhone users must pay for their bandwidth, either on a per-megabyte basis, or once they cross some threshold. Your application must respect this reality.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION4" title="Latency"></a><h3 class="jump">Latency</h3><p>Every network takes time to move data between the two communicating peers; that delay is known as the latency. Latency is typically expressed in terms of a round trip time, which is the time it takes for a packet to go from the source to the destination peer, plus the time it takes for a reply packet to make the return trip.</p><p>Depending on the network protocol you're using, latency can seriously impact your network performance. For example, let's say you want to move five packets of data from one machine to another. You have two design choices:</p><ol class="ol"><li class="li"><p>send #1, wait for ack, send #2, wait for ack, and so on</p></li><li class="li"><p>send #1 through #5, wait for all the acks</p></li></ol><p>Someone new to networking might choose option 1 because it's easier to implement; that would be a mistake. Consider what happens if the round trip latency is 200 ms (a typical value in the wider Internet). Option 1 will take at least one second to transfer the five packets, <strong>regardless of the network bandwidth</strong>. The alternative, option 2, will transfer the same data in a little over 200 ms.</p><p>Latency is an especially bad problem on WWANs. Current WWAN technology will typically introduce a 200-300 ms latency in the first hop!</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION5" title="Malicious Attack"></a><h3 class="jump">Malicious Attack</h3><p>Whenever you communicate on the Internet you open yourself up to malicious attack. In the worst-case scenario an attacker can craft a packet that causes your application to execute arbitrary code, at which point the attacker can take over the machine on which you're running and turn it into a <span class="content_text"><a href="http://en.wikipedia.org/wiki/Zombie_computer" class="urlLink" rel="external">zombie</a></span>. You must carefully check all data that you receive from the network to prevent this.</p><p>iOS is less vulnerable to this sort of problem than Mac OS X because iOS puts strict limits on what memory within your process can be executed as code. Do not use this as an excuse to be complacent about this issue!  Malicious attackers are continually finding new ways to exploit bugs like this.</p></section><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION7" title="Networking Problems With Architecture-Specific Solutions"></a><h2 class="jump">Networking Problems With Architecture-Specific Solutions</h2><p>Any networking code must deal with a certain set of fundamental problems. Some of these problems can only be solved in the context of your overall architecture. The following subsections describe these problems; their solutions are described in the later sections that discuss specific networking designs.</p><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION7" title="Service Discovery"></a><h3 class="jump">Service Discovery</h3><p>Service discovery is the process whereby networking peers learn about the existence and address of other networking peers. Back in the day, service discovery was a challenging problem in some cases. These days there are simple solutions for this problem, although the approach you use depends on your networking architecture.</p><p>See <span class="content_text"><!--a  -->Solutions For Centralized Server Designs<!--/a--></span> for information about service discovery in a centralized server architecture, and <span class="content_text"><!--a  -->Solutions For Peer-To-Peer Designs<!--/a--></span> for information about peer-to-peer service discovery.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION8" title="Authorization"></a><h3 class="jump">Authorization</h3><p>It's obvious that your application must authorize its communications: your application is the guardian of the user's data—it mustn't hand that data over to just anyone.</p><p>What's less obvious is that authorization must be mutual. If you're new to networking you might implement an authorization protocol like:</p><ol class="ol"><li class="li"><p>client connects to server</p></li><li class="li"><p>client sends the password </p></li><li class="li"><p>server checks password and, if it's incorrect, disconnects</p></li><li class="li"><p>if the server didn't disconnect, the client sends the data</p></li></ol><p>Protocols like this are susceptible to impersonation. Someone can run a server that pretends to be the real server, and that server, in step 3, always allows the client to connect regardless of the password sent in step 2. Your client will connect to such a server, successfully 'authorize', and then transmit the user's valuable data to the imposter.</p><p>Worse yet, the imposter now has a copy of the user's password, which is particularly bad if, like many people, the user uses the same password for a variety of services.</p><p>The solution to the overall authorization problem will depend on your networking design, as described in <span class="content_text"><!--a  -->Solutions For Centralized Server Designs<!--/a--></span> and <span class="content_text"><!--a  -->Solutions For Peer-To-Peer Designs<!--/a--></span>.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION9" title="On-The-Wire Privacy"></a><h3 class="jump">On-The-Wire Privacy</h3><p>You must assume that malicious users are looking at every piece of data you transfer over the network. If you ever transfer any data that might be considered personal in the least way, you must ensure that this data is encrypted on the wire.</p><p>In general I recommend that you err on the side of caution and consider all user data to be personal. This is because data that you might not consider especially sensitive might be very sensitive in certain contexts. For example, if you're implementing a remote control application for a home media server, you might not consider the names of the tracks to be sensitive, but it's not hard to imagine at least two scenarios where a user might.</p><p>The exact details of your solution to the privacy problem will depend on your overall networking design; see <span class="content_text"><!--a  -->Solutions For Centralized Server Designs<!--/a--></span> and <span class="content_text"><!--a  -->Solutions For Peer-To-Peer Designs<!--/a--></span> for the details.</p></section><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION11" title="On TLS"></a><h2 class="jump">On TLS</h2><p>Regardless of your overall networking architecture it's likely that TLS (that is, Transport Layer Security or its predecessor, SSL, Secure Sockets Layer) will be part of your solution to the authorization and privacy problems:</p><ul class="ul"><li class="li"><p>For authorization, it's generally a bad idea to use simple password-based authorization because users are notoriously bad at choosing passwords, making password authorization vulnerable to dictionary attacks. A better solution is to use some sort of pairing scheme, where the password is only used to set up the pairing and subsequent authorization is done by other means (for example, via TLS certificates).</p></li><li class="li"><p>For privacy, TLS is the only standard encrypted networking API on iOS. To use any other on-the-wire encryption you would have to either implement another protocol yourself or, worse yet, implement some custom on-the-wire encryption. The latter might seem easy, but it has two key disadvantages:</p><ul class="nested"><li class="nested li"><p>On-the-wire encryption is notoriously hard to get right, and such protocols should be designed by security experts.</p></li><li class="nested li"><p>Any custom encryption scheme is going to be harder to explain to the happy folk who manage US export compliance.</p></li></ul></li></ul><p>If you're not familiar with the capabilities of TLS it would be a good idea to become so. I found the following resources, particularly the last one, to be helpful:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" class="urlLink" rel="external">Transport Layer Security</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://en.wikipedia.org/wiki/X.509" class="urlLink" rel="external">X.509</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://en.wikipedia.org/wiki/PKCS12" class="urlLink" rel="external">PKCS#12</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://luxsci.com/blog/how-does-secure-socket-layer-ssl-or-tls-work.html" class="urlLink" rel="external">How Does Secure Socket Layer (SSL or TLS) Work?</a></span></p></li></ul><p>The key features of TLS are:</p><ul class="ul"><li class="li"><p>An X.509 identity consists of an X.509 certificate (which has a public key embedded within it) and a private key (where the private key matches the public key in the certificate).</p></li><li class="li"><p>A TLS server must apply an identity to its end of the connection. A TLS client may also apply an identity to its end of the connection. After the TLS handshake, the client gets the certificate from the identity of the server and knows that the server holds the private key matching the public key in that certificate. Likewise, if the client applies an identity to its end of the connection, the server can get its associated certificate and know that the client holds the private key matching the public key in that certificate.</p></li><li class="li"><p>Each peer can then look at the certificate of the remote peer and decide whether to trust that peer. For the client this typically involves checking whether the name in the certificate matches the name of the server it tried to connect to, and then validating the X.509 certificate chain up to a trusted root. However, the actual validation done is a matter of policy on the peer doing the validation. For example, a typical Internet server does no validation of client identities.</p></li></ul><p>The recommended TLS API on both iOS and Mac OS X is CFStream. In addition, you can access HTTPS (that is, HTTP over TLS) via the CFHTTPStream API or the NSURLConnection API. On Mac OS X, you can also use the lower-level <span class="content_text"><a href="../../../mac/_documentation/Security/Reference/secureTransportRef/Reference/mac.html" class="browserLink" >Secure Transport</a></span> API.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_4" title="Important"></a><p><strong>Important:</strong>&nbsp;CFStream is toll-free bridged to NSStream. So, once you have your streams set up, you can operate on them as if they were NSStreams. For an example of this, see the <span class="content_text"><a href="../../../mac/navigation/topic_details/resourceType_5.html" class="urlLink" rel="external">Sample Code 'SimpleNetworkStreams'</a></span> sample code.</p><p></p></aside></div><p>For more information on these APIs, see the following resources:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../../_documentation/Cocoa/Conceptual/URLLoadingSystem/ios.html" class="browserLink" >URL Loading System</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../_documentation/Cocoa/Conceptual/Streams/ios.html" class="browserLink" >Stream Programming Guide for Cocoa</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../_documentation/Networking/Conceptual/CFNetwork/Introduction/ios.html" class="browserLink" >CFNetwork Programming Guide</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../mac/_documentation/Security/Reference/secureTransportRef/Reference/mac.html" class="browserLink" >Secure Transport Reference</a></span></p></li></ul><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION12" title="Networking Designs"></a><h2 class="jump">Networking Designs</h2><p>There are two fundamentally different designs you can use for your networking code:</p><ul class="ul"><li class="li"><p><strong>centralized</strong> — In this design you have a single server that's on the public Internet, and all clients connect to that server.</p></li><li class="li"><p><strong>peer-to-peer</strong> — In this design your clients talk to each other, without going through a single central server.</p></li></ul><p>Each approach has its pros and cons. The major disadvantage of a centralized server is the server itself; you have to create and run a server on behalf of your users. This can be a daunting task for a small developer (or, indeed, for a large developer with a lot of users; ask the MobileMe team!). Also, it means that you end up storing user data on your server, which has all sorts of wacky legal implications.</p><p>Another disadvantage with the centralized approach is latency. For certain latency-sensitive applications, most notably action games, the round trip time to the centralized server will be prohibitively long.</p><p>In contrast there are numerous disadvantages with the peer-to-peer approach. The first, and hardest to avoid, is the various link layer issues. iOS devices currently support three link layers for networking (WWAN, Wi-Fi, and Bluetooth), and all of them present challenges for peer-to-peer use. These are discussed in detail in the subsequent sections.</p><p>Finally, TLS was really designed with the centralized server model in mind, and using it in a peer-to-peer fashion is tricky. It's not impossible to make it work, but you're definitely swimming against the tide.</p><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION12" title="WWAN Link-Layer Issues"></a><h3 class="jump">WWAN Link-Layer Issues</h3><p>It's not possible to do peer-to-peer over the WWAN for a number of reasons:</p><ul class="ul"><li class="li"><p>If one of the peers is also bound to a Wi-Fi network, iOS will typically shut down the WWAN interface and send all data via the Wi-Fi.</p></li><li class="li"><p>In general an iPhone will only power up its WWAN interface if it's in use. This makes it impractical to listen for incoming connections on the WWAN interface.</p></li><li class="li"><p>Devices on different WWAN technologies (for example, EDGE versus 3G) may be on different networks.</p></li><li class="li"><p>Even if none of the above apply, cellular carriers generally prevent peer-to-peer WWAN communications as a security measure.</p></li></ul></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION13" title="Wi-Fi Link Layer Issues"></a><h3 class="jump">Wi-Fi Link Layer Issues</h3><p>If two peers are on the same Wi-Fi network, they can generally communicate peer-to-peer. There are, however, issues with this:</p><ul class="ul"><li class="li"><p>Some Wi-Fi hotspots prevent peer-to-peer communications as a security measure.</p></li><li class="li"><p>It's not always easy to get the two peers on the same Wi-Fi network. For example, if you're at a hotspot you may have to pay for access, and paying again just so you can sync your iPhone to your Mac is less than ideal.</p></li></ul><p>Another option on the Wi-Fi front is an ad-hoc (IBSS) network. The problems with this include:</p><ul class="ul"><li class="li"><p>There's no way to create such a network from an iOS device, which makes it impractical for device-to-device communications.</p></li><li class="li"><p>Most peers can't be on both an infrastructure-based and an ad-hoc network simultaneously, which can make things very inconvenient. To continue the example above, having to take your Mac off the hotspot network just to sync up with your iPhone is less than ideal.</p></li></ul></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION14" title="Bluetooth Link Layer Issues"></a><h3 class="jump">Bluetooth Link Layer Issues</h3><p>iOS 3.0 and later support peer-to-peer networking via Bluetooth. While this is a great technology, it still has a number of gotchas:</p><ul class="ul"><li class="li"><p>It requires iOS 3.0 or later.</p></li><li class="li"><p>Bluetooth networking is not available on certain hardware (specifically, the first generation iPhone and iPod touch).</p></li></ul><p>An important consequence of the first point is that Bluetooth peer-to-peer networking can only be used to communicate between iOS devices; you can't use it, for example, to communicate between an iOS device and a computer running Mac OS X.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_5" title="Important"></a><p><strong>Important:</strong>&nbsp;While GameKit is a convenient way to access Bluetooth peer-to-peer networking, you don't have to use GameKit. Applications that browse for services via Bonjour will automatically work over Bluetooth.</p><p></p></aside></div></section><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION16" title="Solutions For Centralized Server Designs"></a><h2 class="jump">Solutions For Centralized Server Designs</h2><p>As mentioned <span class="content_text"><!--a  -->above<!--/a--></span>, by far the hardest part of implementing the centralized server design is running the server itself. The details of this are outside the scope of this document (although <span class="content_text"><!--a  -->see below<!--/a--></span>). Assuming you've got a good handle on that problem, the centralized server design makes it pretty easy to solve your other networking problems, as described in the following subsections.</p><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION16" title="Service Discovery"></a><h3 class="jump">Service Discovery</h3><p>Discovering a centralized server is trivial: just assign your server a fixed DNS name and hard-wire that DNS name into your clients. Problem solved!</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION17" title="Authorization"></a><h3 class="jump">Authorization</h3><p>As discussed above, there are two aspects to the authorization problem:</p><ul class="ul"><li class="li"><p>client/server — The client must check that it's talking to the right server.</p></li><li class="li"><p>server/client — The server must authorize the client.</p></li></ul><p>With a centralized server, the client/server problem has an easy solution: TLS!  As part of setting up your server you should create a TLS identity for that server and have its associated certificate signed by one of the certificate authorities trusted by iOS. Then, when the client connects to the server, the TLS mechanism guarantees that it connected to the correct server.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;The following AppleCare articles list the trusted root certificates built-in to iOS 2.x and 3.0, respectively:</p><p></p></aside></div><ul class="ul"><li class="li"><p><span class="content_text"><a href="http://support.apple.com/kb/HT2185" class="urlLink" rel="external">iOS 2.x: List of Available Trusted Root Certificates</a></span></p></li><li class="li"><p><span class="content_text"><a href="http://support.apple.com/kb/HT3580" class="urlLink" rel="external">iOS 3.0: List of Available Trusted Root Certificates</a></span></p></li></ul><p>Server/client authorization is trickier, and the solution you use largely depends on the server infrastructure you have available. For example, you might be able to piggyback off the authorization infrastructure supported by your server's host, or you could use TLS client-side identities, or your could use a simple password-based authorization mechanism. There are lots of choices and it's hard to decide on what to use without knowing the specific details of your server.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_7" title="Important"></a><p><strong>Important:</strong>&nbsp;If you use client-side identities you will not be able to implement your server using CFSocketStream. CFSocketStream does not provide a way for the server to request that the client provide a certificate 
			(r. <span class="content_text"><a href="rdar://problem/6046415" class="urlLink" rel="external">6046415</a></span>)
		. This is not a limitation if your server uses some other platform, or some other API (for example, on Mac OS X you can avoid this problem by using Secure Transport or OpenSSL).</p><p></p></aside></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION18" title="On-The-Wire Privacy"></a><h3 class="jump">On-The-Wire Privacy</h3><p>If you use TLS and your centralized server has an identity whose certificate is signed by a trusted root, you get on-the-wire encryption automatically.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION19" title="Renting Infrastructure"></a><h3 class="jump">Renting Infrastructure</h3><p>As mentioned earlier, the hardest part about implementing a centralized server is actually deploying the server. However, you should not let this discourage you. There are a variety of services that can help you with this. For example:</p><ul class="ul"><li class="li"><p>MobileMe and iDisk — If you just want to upload and download files to some easily-accessible central server, it's very easy to do this using the user's iDisk. Remember that an iDisk is just a WebDAV server, and WebDAV is just HTTP, so uploading or downloading a file is just a simple HTTP transaction.</p><p>One nice feature of this approach is that the user authorizes using their MobileMe credentials, which is very easy to explain.</p><p>The chief disadvantage of this approach is that the user must subscribe to MobileMe.</p></li><li class="li"><p>Other Services — For something more complex you could use one of many back-end providers to implement your service. Two notable examples are:</p><ul class="nested"><li class="nested li"><p><span class="content_text"><a href="http://code.google.com/appengine/" class="urlLink" rel="external">Google App Engine</a></span></p></li><li class="nested li"><p><span class="content_text"><a href="http://aws.amazon.com/ec2/" class="urlLink" rel="external">Amazon EC2</a></span></p></li></ul><p>but there are many, many more.</p></li></ul></section><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION21" title="Solutions For Peer-To-Peer Designs"></a><h2 class="jump">Solutions For Peer-To-Peer Designs</h2><p>If you've decided to take the peer-to-peer route, you still have to solve the various problems <span class="content_text"><!--a  -->described earlier<!--/a--></span>. The following subsections describe how to do that.</p><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION21" title="Service Discovery"></a><h3 class="jump">Service Discovery</h3><p>In the peer-to-peer case you can implement service discovery using Bonjour. The following resources describe Bonjour in detail:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../../../../bonjour/index.html" class="browserLink" >Bonjour Web Site</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../mac/_documentation/Cocoa/Conceptual/NetServices/mac.html" class="browserLink" >Bonjour Overview</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../_documentation/Networking/Conceptual/NSNetServiceProgGuide/ios.html" class="browserLink" >NSNetServices and CFNetServices Programming Guide</a></span></p></li><li class="li"><p><span class="content_text"><a href="../../../mac/navigation/topic_details/resourceType_5.html" class="urlLink" rel="external">Sample Code 'WiTap'</a></span></p></li></ul><p>You can also do service discovery via GameKit, which in turns uses Bonjour.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION22" title="Authorization"></a><h3 class="jump">Authorization</h3><p>There's no obvious path to implementing authorization in the peer-to-peer case; the solution space is wide open. A good approach is to design your user interface first and then implement an authorization system based on that. Common user interface designs include:</p><ul class="ul"><li class="li"><p>authenticate each time — Each time the user connects to the service they must provide their credentials (at least a password, but in many cases a user name as well). You can make this a little more user friendly by storing the password in the keychain on the client.</p><p>The iOS Mail application uses this user interface.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_8" title="Important"></a><p><strong>Important:</strong>&nbsp;See the <span class="content_text"><!--a  -->comment above<!--/a--></span> about the security issues associated with passwords.</p><p></p></aside></div></li><li class="li"><p>authenticate first time — During the first connection the user must enter some credential, and that process generates an authorization token that is used for subsequent connections. This approach is commonly referred to as pairing.</p><p>The iOS Remote application uses this user interface.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_9" title="Important"></a><p><strong>Important:</strong>&nbsp;You can use a TLS client-side identity as an authorization token. That is, you can ignore the details of the identity's certificate, and authorize the connection based on a simple certificate comparison. However, be aware of the limitations of <span class="content_text"><!--a  -->CFSocketStream's server support<!--/a--></span> and the difficulties with <span class="content_text"><!--a  -->creating identities from scratch<!--/a--></span>.</p><p></p></aside></div></li><li class="li"><p>authenticate never — This is an even simpler variant of the above, where the user doesn't even have to authenticate the first time around. Instead the first connection causes the client and server to pair. This allows for a very simple user interface that is fully secure except during the setup phase.</p></li></ul><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSUBSECTION22" title="Creating Identities"></a><h4 class="jump">Creating Identities</h4><p>As mentioned earlier, TLS is really designed for use with centralized servers, and is not a good match for peer-to-peer networking. The key problem is that TLS is based on X.509 identities, and these identities are expected to contain the DNS name of the remote peer and to be signed by a trusted root. Neither of these requirements are practical in a peer-to-peer networking design.</p><p>It is possible to use TLS in a peer-to-peer network design; you just have to bend the rules a little. The idea is to disable the automatic certificate validation done by TLS and to validate the peer certificate yourself. In this model you don't really need to look inside the certificate; all you need to do is to compare the certificate to a known good certificate that you acquired during pairing.</p><p>The main stumbling block is that each peer must have a unique X.509 identity, and creating such an identity is tricky. Currently there are no straightforward APIs for creating an identity on iOS or Mac OS X. However, there are a number of ways to get around this limitation:</p><ul class="ul"><li class="li"><p>Have some centralized server issue an identity, perhaps using something like <span class="content_text"><a href="http://en.wikipedia.org/wiki/Simple_Certificate_Enrollment_Protocol" class="urlLink" rel="external">Simple Certificate Enrollment Protocol</a></span> (SCEP). These identities may be self-signed or signed by the identity associated with the server.</p></li><li class="li"><p>Generate a self-signed identity on the peers. While there are no good APIs for doing this, you can create an identity on Mac OS X by sublaunching the <code>openssl</code> command line tool.</p></li></ul></section></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION24" title="On-The-Wire Privacy"></a><h3 class="jump">On-The-Wire Privacy</h3><p>Even in a peer-to-peer situation, TLS gives a certain degree of on-the-wire privacy regardless. Specifically, TLS will protect from third party snooping of your traffic. It will not automatically protect you from server spoofing (or, indeed, man-in-the-middle attacks); you would typically gain such protection as the result of your pairing process.</p></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SUBSECTION25" title="On GameKit"></a><h3 class="jump">On GameKit</h3><p>GameKit addresses some, but not all, of the problems associated with peer-to-peer networking. Most importantly, it provides an easy way to do networking over Bluetooth, which addresses many of the problems associated with peer-to-peer networking over <span class="content_text"><!--a  -->Wi-Fi<!--/a--></span>. It also takes care of service discovery for you. However, it does not address any of the security issues described above and, more to the point, it makes it harder to address these issues because there's no easy way to use TLS to protect your GameKit session.</p></section><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION27" title="Protocol Issues"></a><h2 class="jump">Protocol Issues</h2><p>Once you've decided on your high-level design, you then have to think about the specific details of the on-the-wire transactions. The first step is to decide on an overall framework for your network transactions. There are two obvious choices:</p><ul class="ul"><li class="li"><p>HTTP</p></li><li class="li"><p>a custom TCP-based protocol</p></li></ul><p>Depending on your server architecture this may be a non-issue. For example, if you use the Google App Engine for your server, your transactions must necessarily be framed in HTTP. In the absence of such constraints, you should consider the following points:</p><ul class="ul"><li class="li"><p>HTTP is probably the most robust way of connecting to a centralized server. There are environments where HTTP will work but a custom TCP connection will not (for example, behind an HTTP proxy).</p></li><li class="li"><p>HTTP is a natural fit for some transactions but not for others. For example, if you need to do client/server request/response transactions, where the client always sends a request to which the server responds promptly, HTTP is a great fit. On the other hand, if the server needs to be able to inform the client of asynchronous events, HTTP is less than ideal.</p><p>Of course, in that case, you may want to investigate the <span class="content_text"><a href="../../_documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ios.html" class="browserLink" >push notification</a></span> mechanism introduced with iOS 3.0.</p></li><li class="li"><p>iOS has many nice HTTP client APIs. Its HTTP server APIs are not as rich; you have to do a lot more work yourself. Thus, for peer-to-peer designs, a custom protocol is more attractive.</p></li></ul><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION28" title="File Transfer Protocols"></a><h2 class="jump">File Transfer Protocols</h2><p>A common high-level goal is to transfer files from one machine to another. There are many ways to do this, but two of the most common mechanisms have serious gotchas:</p><ul class="ul"><li class="li"><p>FTP — Anonymous FTP is an acceptable way to download publicly-visible files. However, you should avoid any other use of FTP like the plague. Specifically, authenticated FTP will send your user's password in plaintext on the wire. This is not acceptable on the modern Internet. Moreover, all forms of FTP send the data in the clear, which is not appropriate for any user data.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;There have been numerous attempts to make a secure 'FTP'. </p><p></p></aside></div><p>These include:</p><ul class="nested"><li class="nested li"><p><span class="content_text"><a href="http://en.wikipedia.org/wiki/FTPS" class="urlLink" rel="external">FTPS</a></span> — This is FTP over TLS. It is not supported by any  built-in APIs on iOS or Mac OS X.</p></li><li class="nested li"><p><span class="content_text"><a href="http://en.wikipedia.org/wiki/SSH_file_transfer_protocol" class="urlLink" rel="external">SFTP</a></span> — This is a new file transfer protocol based on SSH. There are no SSH APIs built in to either iOS or Mac OS X. On Mac OS X you can access SSH functionality by sublaunching various command line tools. This is not an option on iOS.</p></li></ul></li><li class="li"><p>AFP — Given that AFP is the default sharing protocol on Mac OS X, it seems logical to transfer files between a device and a Mac by implementing an AFP client on the device. This is tricky. AFP is quite a complicated protocol, and there's no high-level API for it on iOS. Moreover, AFP is a very Mac-centric protocol, which is a problem if you want to sell your application to users of other platforms.</p></li></ul><p>If you want to support a file sharing protocol the most obvious choices are <span class="content_text"><a href="http://en.wikipedia.org/wiki/WebDAV" class="urlLink" rel="external">WebDAV</a></span> and <span class="content_text"><a href="http://en.wikipedia.org/wiki/Server_Message_Block" class="urlLink" rel="external">SMB</a></span>. Still, this is not easy. There are no high-level APIs for these protocols on iOS or Mac OS X, although WebDAV is layered on top of HTTP so the various HTTP APIs make implementing WebDAV easier.</p><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><section><a name="//apple_ref/doc/uid/DTS40009179-CH1-SECTION29" title="Syncing Issues"></a><h2 class="jump">Syncing Issues</h2><p>Another common high-level goal is to sync data structures between two or more machines. Once you've created a reliable and secure network connection between your machines, you can start thinking about what it would take to sync your data between them.</p><p>Ultimately your syncing design will be driven by your user experience needs, combined with the amount of programming time you're prepared to invest to achieve that user experience. Some common approaches include:</p><ul class="ul"><li class="li"><p>manual transfers — A totally manual transfer process does not present a large technical challenge. In fact, this is pretty much equivalent to file transfer.</p></li><li class="li"><p>full syncing — On the other hand, a fully automatic syncing process, where the application can merge changes made independently on multiple different machines, is quite challenging.</p></li><li class="li"><p>something in between — For example, if you have a data logging application, syncing is much easier because each datum is read-only and is sourced from one specific machine.</p></li></ul><p>Regardless of your syncing needs, you will have to write all of this code yourself. iOS does not provide any specific high-level support for syncing (for example, there's no equivalent of Sync Services on iOS).</p><div class="back_to_top"><a href="_index.html#top">Back to Top</a></div></section><br/><hr/><a name="//apple_ref/doc/uid/DTS40009179-CH1-DontLinkElementID_1" title="Document Revision History"></a><a name="//apple_ref/doc/uid/DTS40009179-RevisionHistory-DontLinkElementID_1" title="Document Revision History"></a><h4>Document Revision History</h4><br/><table class="graybox revision-history" border="0" cellspacing="0" cellpadding="5"><colgroup span="1"><col width="145" /></colgroup><tr><th scope="col" align="left"><strong>Date</strong></th><th scope="col" align="left"><strong>Notes</strong></th></tr><tr><td scope="row">2010-07-26</td><td><p>Updated to reflect the introduction of iTunes file sharing. Some other minor updates.</p></td></tr><tr><td scope="row">2010-01-29</td><td><p>A minor change to clarify the availability of Bluetooth peer-to-peer networking, plus various editorial tweaks.</p></td></tr><tr><td scope="row">2009-08-25</td><td><p>New document that 
					describes various strategies for device-to-device and device-to-computer document transfer.</p></td></tr></table><br/>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2010 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2010-07-26</p></div></div>

        <!-- /CONTENTS -->
        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <input id="email" type="email" name="email" placeholder="Email (optional)" size="48">

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="../../../../bug-reporting/index.html" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../Resources/874/JavaScript/lib/prototype.js"></script>
    <script src="../../Resources/874/JavaScript/library.js"></script>
    <script src="../../Resources/874/JavaScript/feedback.js"></script>
</body>
<script type="text/javascript" src="../../../webstats/pagetracker.js"></script>
<script type="text/javascript">
if(typeof PageTracker !== 'undefined') {
  if(window.addEventListener) {
    window.addEventListener("load", function(){PageTracker.logPageLoad()},false);
  } else if(window.attachEvent) {
    window.attachEvent("onload",function(){PageTracker.logPageLoad()});
  }
}
</script>
</html>
