<!DOCTYPE html>
<html lang="en">
<head>
    <title>AVPlayerDemo: Classes/AVPlayerDemoPlaybackViewController.m</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Sample Code">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/DTS40010101">
	<meta id="document-version" name="document-version" content="2.1.0">
    <meta id="build" name="build" content="bcf073e0579478458b78c3b3068a2133">
    <meta id="chapterId" name="chapterId" content="DTS40010101-Classes_AVPlayerDemoPlaybackViewController_m">
    <meta id="date" name="date" content="2013-06-07">
    <meta id="description" name="description" content="Uses AVPlayer to play videos from iPod Library, Camera Roll, or via iTunes File Sharing.">
    <meta id="book-title" name="book-title" content="AVPlayerDemo">
    <meta id="book-name" name="book-name" content="DTS_SC2095_AVPlayerDemo">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="iOS Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/ios">
    <meta id="reflib" name="reflib" content="iOS Developer Library">
    <meta id="book-assignments" name="book-assignments" content="{Type/Sample Code}, {Framework/Media Layer/AVFoundation}, {Topic/Audio & Video/Video}">
    
    
    <meta id="generator" name="generator" content="Gutenberg 003a3034">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2014 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Classes/AVPlayerDemoPlaybackViewController.m">
    <meta id="resources-uri" name="resources-uri" content="../../../Resources/874">
    <link id="book-index-page" rel="Start" title="AVPlayerDemo" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../History/History.html">
    <link id="previous-page" rel="Prev" type="text/html" href="Classes_AVPlayerDemoPlaybackViewController_h.html">
    <link rel="stylesheet" type="text/css" href="../../../Resources/874/CSS/screen.css">
    
    <link rel="stylesheet" type="text/css" href="../../../Resources/874/CSS/feedback.css">
</head>    
<body><a name="//apple_ref/doc/uid/DTS40010101-Classes_AVPlayerDemoPlaybackViewController_m" title="Classes/AVPlayerDemoPlaybackViewController.m"></a>
    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode phone">
            <a id="ssi_LibraryTitle" href='../../../navigation/index.html'>iOS Developer Library</a>
            <a id="ssi_AppleDeveloperConnection" href='../../../../../index.html'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search iOS Developer Library</label>
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>AVPlayerDemo</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../History/History.html'>Next</a><a class='previousLink' rel='prev' href='Classes_AVPlayerDemoPlaybackViewController_h.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/DTS40010101-Classes_AVPlayerDemoPlaybackViewController_m-DontLinkElementID_8" title="Classes/AVPlayerDemoPlaybackViewController.m"></a>
    <h1 id="pageTitle">Classes/AVPlayerDemoPlaybackViewController.m</h1>
    <div class="codesample clear"><table><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>File: AVPlayerDemoPlaybackViewController.h<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Abstract: UIViewController managing a playback view, thumbnail view, and associated playback UI.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Version: 1.1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Disclaimer: IMPORTANT:  This Apple software is supplied to you by <span></span></pre></td></tr><tr><td scope="row"><pre>Apple Inc. ("Apple") in consideration of your agreement to the<span></span></pre></td></tr><tr><td scope="row"><pre>following terms, and your use, installation, modification or<span></span></pre></td></tr><tr><td scope="row"><pre>redistribution of this Apple software constitutes acceptance of these<span></span></pre></td></tr><tr><td scope="row"><pre>terms.  If you do not agree with these terms, please do not use,<span></span></pre></td></tr><tr><td scope="row"><pre>install, modify or redistribute this Apple software.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>In consideration of your agreement to abide by the following terms, and<span></span></pre></td></tr><tr><td scope="row"><pre>subject to these terms, Apple grants you a personal, non-exclusive<span></span></pre></td></tr><tr><td scope="row"><pre>license, under Apple's copyrights in this original Apple software (the<span></span></pre></td></tr><tr><td scope="row"><pre>"Apple Software"), to use, reproduce, modify and redistribute the Apple<span></span></pre></td></tr><tr><td scope="row"><pre>Software, with or without modifications, in source and/or binary forms;<span></span></pre></td></tr><tr><td scope="row"><pre>provided that if you redistribute the Apple Software in its entirety and<span></span></pre></td></tr><tr><td scope="row"><pre>without modifications, you must retain this notice and the following<span></span></pre></td></tr><tr><td scope="row"><pre>text and disclaimers in all such redistributions of the Apple Software. <span></span></pre></td></tr><tr><td scope="row"><pre>Neither the name, trademarks, service marks or logos of Apple Inc. <span></span></pre></td></tr><tr><td scope="row"><pre>may be used to endorse or promote products derived from the Apple<span></span></pre></td></tr><tr><td scope="row"><pre>Software without specific prior written permission from Apple.  Except<span></span></pre></td></tr><tr><td scope="row"><pre>as expressly stated in this notice, no other rights or licenses, express<span></span></pre></td></tr><tr><td scope="row"><pre>or implied, are granted by Apple herein, including but not limited to<span></span></pre></td></tr><tr><td scope="row"><pre>any patent rights that may be infringed by your derivative works or by<span></span></pre></td></tr><tr><td scope="row"><pre>other works in which the Apple Software may be incorporated.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>The Apple Software is provided by Apple on an "AS IS" basis.  APPLE<span></span></pre></td></tr><tr><td scope="row"><pre>MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION<span></span></pre></td></tr><tr><td scope="row"><pre>THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS<span></span></pre></td></tr><tr><td scope="row"><pre>FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND<span></span></pre></td></tr><tr><td scope="row"><pre>OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL<span></span></pre></td></tr><tr><td scope="row"><pre>OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<span></span></pre></td></tr><tr><td scope="row"><pre>SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<span></span></pre></td></tr><tr><td scope="row"><pre>INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,<span></span></pre></td></tr><tr><td scope="row"><pre>MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED<span></span></pre></td></tr><tr><td scope="row"><pre>AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),<span></span></pre></td></tr><tr><td scope="row"><pre>STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE<span></span></pre></td></tr><tr><td scope="row"><pre>POSSIBILITY OF SUCH DAMAGE.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Copyright (C) 2010-2013 Apple Inc. All Rights Reserved.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#import "AVPlayerDemoPlaybackViewController.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "AVPlayerDemoPlaybackView.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "AVPlayerDemoMetadataViewController.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Asset keys */<span></span></pre></td></tr><tr><td scope="row"><pre>NSString * const kTracksKey         = @"tracks";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString * const kPlayableKey       = @"playable";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* PlayerItem keys */<span></span></pre></td></tr><tr><td scope="row"><pre>NSString * const kStatusKey         = @"status";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* AVPlayer keys */<span></span></pre></td></tr><tr><td scope="row"><pre>NSString * const kRateKey           = @"rate";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString * const kCurrentItemKey    = @"currentItem";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface AVPlayerDemoPlaybackViewController ()<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)play:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)pause:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)showMetadata:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)initScrubberTimer;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)showPlayButton;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)showStopButton;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncScrubber;<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)beginScrubbing:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)scrub:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)endScrubbing:(id)sender;<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isScrubbing;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc;<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewDidLoad;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewWillDisappear:(BOOL)animated;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleSwipe:(UISwipeGestureRecognizer*)gestureRecognizer;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncPlayPauseButtons;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setURL:(NSURL*)URL;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSURL*)URL;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface AVPlayerDemoPlaybackViewController (Player)<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removePlayerTimeObserver;<span></span></pre></td></tr><tr><td scope="row"><pre>- (CMTime)playerItemDuration;<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isPlaying;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)playerItemDidReachEnd:(NSNotification *)notification ;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)observeValueForKeyPath:(NSString*) path ofObject:(id)object change:(NSDictionary*)change context:(void*)context;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareToPlayAsset:(AVURLAsset *)asset withKeys:(NSArray *)requestedKeys;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void *AVPlayerDemoPlaybackViewControllerRateObservationContext = &amp;AVPlayerDemoPlaybackViewControllerRateObservationContext;<span></span></pre></td></tr><tr><td scope="row"><pre>static void *AVPlayerDemoPlaybackViewControllerStatusObservationContext = &amp;AVPlayerDemoPlaybackViewControllerStatusObservationContext;<span></span></pre></td></tr><tr><td scope="row"><pre>static void *AVPlayerDemoPlaybackViewControllerCurrentItemObservationContext = &amp;AVPlayerDemoPlaybackViewControllerCurrentItemObservationContext;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>@implementation AVPlayerDemoPlaybackViewController<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize mPlayer, mPlayerItem, mPlaybackView, mToolbar, mPlayButton, mStopButton, mScrubber;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Asset URL<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setURL:(NSURL*)URL<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (mURL != URL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [mURL release];<span></span></pre></td></tr><tr><td scope="row"><pre>        mURL = [URL copy];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /*<span></span></pre></td></tr><tr><td scope="row"><pre>         Create an asset for inspection of a resource referenced by a given URL.<span></span></pre></td></tr><tr><td scope="row"><pre>         Load the values for the asset keys "tracks", "playable".<span></span></pre></td></tr><tr><td scope="row"><pre>         */<span></span></pre></td></tr><tr><td scope="row"><pre>        AVURLAsset *asset = [AVURLAsset URLAssetWithURL:mURL options:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        NSArray *requestedKeys = [NSArray arrayWithObjects:kTracksKey, kPlayableKey, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Tells the asset to load the values of any of the specified keys that are not already loaded. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [asset loadValuesAsynchronouslyForKeys:requestedKeys completionHandler:<span></span></pre></td></tr><tr><td scope="row"><pre>         ^{      <span></span></pre></td></tr><tr><td scope="row"><pre>             dispatch_async( dispatch_get_main_queue(), <span></span></pre></td></tr><tr><td scope="row"><pre>                            ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                                /* IMPORTANT: Must dispatch to main queue in order to operate on the AVPlayer and AVPlayerItem. */<span></span></pre></td></tr><tr><td scope="row"><pre>                                [self prepareToPlayAsset:asset withKeys:requestedKeys];<span></span></pre></td></tr><tr><td scope="row"><pre>                            });<span></span></pre></td></tr><tr><td scope="row"><pre>         }];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSURL*)URL<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return mURL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Movie controller methods<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Button Action Methods<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)play:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* If we are at the end of the movie, we must seek to the beginning first <span></span></pre></td></tr><tr><td scope="row"><pre>        before starting playback. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (YES == seekToZeroBeforePlay) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        seekToZeroBeforePlay = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mPlayer seekToTime:kCMTimeZero];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer play];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self showStopButton];    <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)pause:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer pause];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self showPlayButton];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Display AVMetadataCommonKeyTitle and AVMetadataCommonKeyCopyrights metadata. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)showMetadata:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    AVPlayerDemoMetadataViewController* metadataViewController = [[AVPlayerDemoMetadataViewController alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [metadataViewController setMetadata:[[[self.mPlayer currentItem] asset] commonMetadata]];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self presentViewController:metadataViewController animated:YES completion:NULL];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [metadataViewController release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Play, Stop buttons<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Show the stop button in the movie player controller. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)showStopButton<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *toolbarItems = [NSMutableArray arrayWithArray:[self.mToolbar items]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [toolbarItems replaceObjectAtIndex:0 withObject:self.mStopButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mToolbar.items = toolbarItems;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Show the play button in the movie player controller. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)showPlayButton<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *toolbarItems = [NSMutableArray arrayWithArray:[self.mToolbar items]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [toolbarItems replaceObjectAtIndex:0 withObject:self.mPlayButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mToolbar.items = toolbarItems;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* If the media is playing, show the stop button; otherwise, show the play button. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncPlayPauseButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self isPlaying])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showStopButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showPlayButton];        <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)enablePlayerButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlayButton.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mStopButton.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)disablePlayerButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlayButton.enabled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mStopButton.enabled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Movie scrubber control<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>**  Methods to handle manipulation of the movie scrubber control<span></span></pre></td></tr><tr><td scope="row"><pre>** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Requests invocation of a given block during media playback to update the movie scrubber control. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)initScrubberTimer<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    double interval = .1f;  <span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    } <span></span></pre></td></tr><tr><td scope="row"><pre>    double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGFloat width = CGRectGetWidth([self.mScrubber bounds]);<span></span></pre></td></tr><tr><td scope="row"><pre>        interval = 0.5f * duration / width;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Update the scrubber during normal playback. */<span></span></pre></td></tr><tr><td scope="row"><pre>    mTimeObserver = [[self.mPlayer addPeriodicTimeObserverForInterval:CMTimeMakeWithSeconds(interval, NSEC_PER_SEC) <span></span></pre></td></tr><tr><td scope="row"><pre>                                queue:NULL /* If you pass NULL, the main queue is used. */<span></span></pre></td></tr><tr><td scope="row"><pre>                                usingBlock:^(CMTime time) <span></span></pre></td></tr><tr><td scope="row"><pre>                                            {<span></span></pre></td></tr><tr><td scope="row"><pre>                                                [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                                            }] retain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Set the scrubber based on the player current time. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        mScrubber.minimumValue = 0.0;<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    } <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        float minValue = [self.mScrubber minimumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        float maxValue = [self.mScrubber maximumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        double time = CMTimeGetSeconds([self.mPlayer currentTime]);<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mScrubber setValue:(maxValue - minValue) * time / duration + minValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The user is dragging the movie controller thumb to scrub through the movie. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)beginScrubbing:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    mRestoreAfterScrubbingRate = [self.mPlayer rate];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer setRate:0.f];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Remove previous timer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Set the player current time to match the scrubber position. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)scrub:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([sender isKindOfClass:[UISlider class]])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        UISlider* slider = sender;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (CMTIME_IS_INVALID(playerDuration)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        } <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            float minValue = [slider minimumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>            float maxValue = [slider maximumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>            float value = [slider value];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            double time = duration * (value - minValue) / (maxValue - minValue);<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            [self.mPlayer seekToTime:CMTimeMakeWithSeconds(time, NSEC_PER_SEC)];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The user has released the movie thumb control to stop scrubbing through the movie. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)endScrubbing:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!mTimeObserver)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        } <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            CGFloat width = CGRectGetWidth([self.mScrubber bounds]);<span></span></pre></td></tr><tr><td scope="row"><pre>            double tolerance = 0.5f * duration / width;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            mTimeObserver = [[self.mPlayer addPeriodicTimeObserverForInterval:CMTimeMakeWithSeconds(tolerance, NSEC_PER_SEC) queue:NULL usingBlock:<span></span></pre></td></tr><tr><td scope="row"><pre>            ^(CMTime time)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>            }] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (mRestoreAfterScrubbingRate)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mPlayer setRate:mRestoreAfterScrubbingRate];<span></span></pre></td></tr><tr><td scope="row"><pre>        mRestoreAfterScrubbingRate = 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isScrubbing<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return mRestoreAfterScrubbingRate != 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)enableScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mScrubber.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)disableScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mScrubber.enabled = NO;    <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark View Controller<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPlayer:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self setWantsFullScreenLayout:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return [self initWithNibName:@"AVPlayerDemoPlaybackView-iPad" bundle:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    } <span></span></pre></td></tr><tr><td scope="row"><pre>    else <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return [self initWithNibName:@"AVPlayerDemoPlaybackView" bundle:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewDidUnload<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlaybackView = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    self.mToolbar = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlayButton = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mStopButton = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mScrubber = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [mTimeObserver release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [mURL release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewDidUnload];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewDidLoad<span></span></pre></td></tr><tr><td scope="row"><pre>{    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPlayer:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    UIView* view  = [self view];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizer* swipeUpRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipe:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeUpRecognizer setDirection:UISwipeGestureRecognizerDirectionUp];<span></span></pre></td></tr><tr><td scope="row"><pre>    [view addGestureRecognizer:swipeUpRecognizer];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeUpRecognizer release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizer* swipeDownRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipe:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeDownRecognizer setDirection:UISwipeGestureRecognizerDirectionDown];<span></span></pre></td></tr><tr><td scope="row"><pre>    [view addGestureRecognizer:swipeDownRecognizer];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeDownRecognizer release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    UIBarButtonItem *scrubberItem = [[UIBarButtonItem alloc] initWithCustomView:self.mScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    UIBarButtonItem *flexItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    UIButton *infoButton = [UIButton buttonWithType:UIButtonTypeInfoLight];<span></span></pre></td></tr><tr><td scope="row"><pre>    [infoButton addTarget:self action:@selector(showMetadata:) forControlEvents:UIControlEventTouchUpInside];<span></span></pre></td></tr><tr><td scope="row"><pre>    UIBarButtonItem *infoItem = [[UIBarButtonItem alloc] initWithCustomView:infoButton];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    self.mToolbar.items = [NSArray arrayWithObjects:self.mPlayButton, flexItem, scrubberItem, infoItem, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [scrubberItem release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [flexItem release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [infoItem release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self initScrubberTimer];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewDidLoad];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewWillDisappear:(BOOL)animated<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer pause];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewWillDisappear:animated];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)setViewDisplayName<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Set the view title to the last component of the asset URL. */<span></span></pre></td></tr><tr><td scope="row"><pre>    self.title = [mURL lastPathComponent];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Or if the item has a AVMetadataCommonKeyTitle metadata, use that instead. */<span></span></pre></td></tr><tr><td scope="row"><pre>    for (AVMetadataItem* item in ([[[self.mPlayer currentItem] asset] commonMetadata]))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString* commonKey = [item commonKey];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        if ([commonKey isEqualToString:AVMetadataCommonKeyTitle])<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            self.title = [item stringValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleSwipe:(UISwipeGestureRecognizer *)gestureRecognizer<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UIView* view = [self view];<span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizerDirection direction = [gestureRecognizer direction];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPoint location = [gestureRecognizer locationInView:view];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    if (location.y &lt; CGRectGetMidY([view bounds]))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionUp)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>            ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self navigationController] setNavigationBarHidden:YES animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>            } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>            ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:UIStatusBarAnimationSlide];<span></span></pre></td></tr><tr><td scope="row"><pre>            }];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionDown)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>            ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                [[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationSlide];<span></span></pre></td></tr><tr><td scope="row"><pre>            } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>            ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self navigationController] setNavigationBarHidden:NO animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>            }];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionDown)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (![self.mToolbar isHidden])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>                ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self.mToolbar setTransform:CGAffineTransformMakeTranslation(0.f, CGRectGetHeight([self.mToolbar bounds]))];<span></span></pre></td></tr><tr><td scope="row"><pre>                } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>                ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self.mToolbar setHidden:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>                }];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else if (direction == UISwipeGestureRecognizerDirectionUp)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if ([self.mToolbar isHidden])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self.mToolbar setHidden:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>                ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self.mToolbar setTransform:CGAffineTransformIdentity];<span></span></pre></td></tr><tr><td scope="row"><pre>                } completion:^(BOOL finished){}];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer removeObserver:self forKeyPath:@"rate"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [mPlayer.currentItem removeObserver:self forKeyPath:@"status"];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayer pause];<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlayer = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [mURL release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation AVPlayerDemoPlaybackViewController (Player)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Player Item<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isPlaying<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return mRestoreAfterScrubbingRate != 0.f || [self.mPlayer rate] != 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Called when the player item has played to its end time. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)playerItemDidReachEnd:(NSNotification *)notification <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* After the movie has played to its end time, seek back to time zero <span></span></pre></td></tr><tr><td scope="row"><pre>        to play it again. */<span></span></pre></td></tr><tr><td scope="row"><pre>    seekToZeroBeforePlay = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Get the duration for a AVPlayerItem. <span></span></pre></td></tr><tr><td scope="row"><pre> ** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (CMTime)playerItemDuration<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    AVPlayerItem *playerItem = [self.mPlayer currentItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (playerItem.status == AVPlayerItemStatusReadyToPlay)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* <span></span></pre></td></tr><tr><td scope="row"><pre>         NOTE:<span></span></pre></td></tr><tr><td scope="row"><pre>         Because of the dynamic nature of HTTP Live Streaming Media, the best practice <span></span></pre></td></tr><tr><td scope="row"><pre>         for obtaining the duration of an AVPlayerItem object has changed in iOS 4.3. <span></span></pre></td></tr><tr><td scope="row"><pre>         Prior to iOS 4.3, you would obtain the duration of a player item by fetching <span></span></pre></td></tr><tr><td scope="row"><pre>         the value of the duration property of its associated AVAsset object. However, <span></span></pre></td></tr><tr><td scope="row"><pre>         note that for HTTP Live Streaming Media the duration of a player item during <span></span></pre></td></tr><tr><td scope="row"><pre>         any particular playback session may differ from the duration of its asset. For <span></span></pre></td></tr><tr><td scope="row"><pre>         this reason a new key-value observable duration property has been defined on <span></span></pre></td></tr><tr><td scope="row"><pre>         AVPlayerItem.<span></span></pre></td></tr><tr><td scope="row"><pre>         <span></span></pre></td></tr><tr><td scope="row"><pre>         See the AV Foundation Release Notes for iOS 4.3 for more information.<span></span></pre></td></tr><tr><td scope="row"><pre>         */     <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        return([playerItem duration]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return(kCMTimeInvalid);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Cancels the previously registered time observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)removePlayerTimeObserver<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (mTimeObserver)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mPlayer removeTimeObserver:mTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>        [mTimeObserver release];<span></span></pre></td></tr><tr><td scope="row"><pre>        mTimeObserver = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Loading the Asset Keys Asynchronously<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Error Handling - Preparing Assets for Playback Failed<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* --------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Called when an asset fails to prepare for playback for any of<span></span></pre></td></tr><tr><td scope="row"><pre> **  the following reasons:<span></span></pre></td></tr><tr><td scope="row"><pre> ** <span></span></pre></td></tr><tr><td scope="row"><pre> **  1) values of asset keys did not load successfully, <span></span></pre></td></tr><tr><td scope="row"><pre> **  2) the asset keys did load successfully, but the asset is not <span></span></pre></td></tr><tr><td scope="row"><pre> **     playable<span></span></pre></td></tr><tr><td scope="row"><pre> **  3) the item did not become ready to play. <span></span></pre></td></tr><tr><td scope="row"><pre> ** ----------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)assetFailedToPrepareForPlayback:(NSError *)error<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Display the error. */<span></span></pre></td></tr><tr><td scope="row"><pre>    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:[error localizedDescription]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        message:[error localizedFailureReason]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                       delegate:nil<span></span></pre></td></tr><tr><td scope="row"><pre>                                              cancelButtonTitle:@"OK"<span></span></pre></td></tr><tr><td scope="row"><pre>                                              otherButtonTitles:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [alertView show];<span></span></pre></td></tr><tr><td scope="row"><pre>    [alertView release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Prepare to play asset, URL<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre> Invoked at the completion of the loading of the values for all keys on the asset that we require.<span></span></pre></td></tr><tr><td scope="row"><pre> Checks whether loading was successfull and whether the asset is playable.<span></span></pre></td></tr><tr><td scope="row"><pre> If so, sets up an AVPlayerItem and an AVPlayer to play the asset.<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareToPlayAsset:(AVURLAsset *)asset withKeys:(NSArray *)requestedKeys<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make sure that the value of each key has loaded successfully. */<span></span></pre></td></tr><tr><td scope="row"><pre>    for (NSString *thisKey in requestedKeys)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSError *error = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        AVKeyValueStatus keyStatus = [asset statusOfValueForKey:thisKey error:&amp;error];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (keyStatus == AVKeyValueStatusFailed)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self assetFailedToPrepareForPlayback:error];<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        /* If you are also implementing -[AVAsset cancelLoading], add your code here to bail out properly in the case of cancellation. */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Use the AVAsset playable property to detect whether the asset can be played. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!asset.playable) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Generate an error describing the failure. */<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *localizedDescription = NSLocalizedString(@"Item cannot be played", @"Item cannot be played description");<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *localizedFailureReason = NSLocalizedString(@"The assets tracks were loaded, but could not be made playable.", @"Item cannot be played failure reason");<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary *errorDict = [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>                                   localizedDescription, NSLocalizedDescriptionKey, <span></span></pre></td></tr><tr><td scope="row"><pre>                                   localizedFailureReason, NSLocalizedFailureReasonErrorKey, <span></span></pre></td></tr><tr><td scope="row"><pre>                                   nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSError *assetCannotBePlayedError = [NSError errorWithDomain:@"StitchedStreamPlayer" code:0 userInfo:errorDict];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Display the error to the user. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self assetFailedToPrepareForPlayback:assetCannotBePlayedError];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* At this point we're ready to set up for playback of the asset. */<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Stop observing our prior AVPlayerItem, if we have one. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self.mPlayerItem)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Remove existing player item key value observers and notifications. */<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mPlayerItem removeObserver:self forKeyPath:kStatusKey];            <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [[NSNotificationCenter defaultCenter] removeObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        name:AVPlayerItemDidPlayToEndTimeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      object:self.mPlayerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create a new instance of AVPlayerItem from the now successfully loaded AVAsset. */<span></span></pre></td></tr><tr><td scope="row"><pre>    self.mPlayerItem = [AVPlayerItem playerItemWithAsset:asset];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Observe the player item "status" key to determine when it is ready to play. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mPlayerItem addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kStatusKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:AVPlayerDemoPlaybackViewControllerStatusObservationContext];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* When the player item has played to its end time we'll toggle<span></span></pre></td></tr><tr><td scope="row"><pre>     the movie controller Pause button to be the Play button */<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                             selector:@selector(playerItemDidReachEnd:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 name:AVPlayerItemDidPlayToEndTimeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                               object:self.mPlayerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    seekToZeroBeforePlay = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create new player, if we don't already have one. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!self.mPlayer)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Get a new AVPlayer initialized to play the specified player item. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPlayer:[AVPlayer playerWithPlayerItem:self.mPlayerItem]];  <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Observe the AVPlayer "currentItem" property to find out when any <span></span></pre></td></tr><tr><td scope="row"><pre>         AVPlayer replaceCurrentItemWithPlayerItem: replacement will/did <span></span></pre></td></tr><tr><td scope="row"><pre>         occur.*/<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.player addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kCurrentItemKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:AVPlayerDemoPlaybackViewControllerCurrentItemObservationContext];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Observe the AVPlayer "rate" property to update the scrubber control. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.player addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kRateKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:AVPlayerDemoPlaybackViewControllerRateObservationContext];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make our new AVPlayerItem the AVPlayer's current item. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self.player.currentItem != self.mPlayerItem)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Replace the player item with a new player item. The item replacement occurs <span></span></pre></td></tr><tr><td scope="row"><pre>         asynchronously; observe the currentItem property to find out when the <span></span></pre></td></tr><tr><td scope="row"><pre>         replacement will/did occur*/<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.mPlayer replaceCurrentItemWithPlayerItem:self.mPlayerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self.mScrubber setValue:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Asset Key Value Observing<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Key Value Observer for player rate, currentItem, player item status<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>**  Called when the value at the specified key path relative<span></span></pre></td></tr><tr><td scope="row"><pre>**  to the given object has changed. <span></span></pre></td></tr><tr><td scope="row"><pre>**  Adjust the movie play and pause button controls when the <span></span></pre></td></tr><tr><td scope="row"><pre>**  player item "status" value changes. Update the movie <span></span></pre></td></tr><tr><td scope="row"><pre>**  scrubber control when the player item is ready to play.<span></span></pre></td></tr><tr><td scope="row"><pre>**  Adjust the movie scrubber control when the player item <span></span></pre></td></tr><tr><td scope="row"><pre>**  "rate" value changes. For updates of the player<span></span></pre></td></tr><tr><td scope="row"><pre>**  "currentItem" property, set the AVPlayer for which the <span></span></pre></td></tr><tr><td scope="row"><pre>**  player layer displays visual output.<span></span></pre></td></tr><tr><td scope="row"><pre>**  NOTE: this method is invoked on the main queue.<span></span></pre></td></tr><tr><td scope="row"><pre>** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)observeValueForKeyPath:(NSString*) path <span></span></pre></td></tr><tr><td scope="row"><pre>            ofObject:(id)object <span></span></pre></td></tr><tr><td scope="row"><pre>            change:(NSDictionary*)change <span></span></pre></td></tr><tr><td scope="row"><pre>            context:(void*)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayerItem "status" property value observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (context == AVPlayerDemoPlaybackViewControllerStatusObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        AVPlayerStatus status = [[change objectForKey:NSKeyValueChangeNewKey] integerValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (status)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Indicates that the status of the player is not yet known because <span></span></pre></td></tr><tr><td scope="row"><pre>             it has not tried to load new media resources for playback */<span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusUnknown:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusReadyToPlay:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Once the AVPlayerItem becomes ready to play, i.e. <span></span></pre></td></tr><tr><td scope="row"><pre>                 [playerItem status] == AVPlayerItemStatusReadyToPlay,<span></span></pre></td></tr><tr><td scope="row"><pre>                 its duration can be fetched from the item. */<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [self initScrubberTimer];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [self enableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self enablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusFailed:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                AVPlayerItem *playerItem = (AVPlayerItem *)object;<span></span></pre></td></tr><tr><td scope="row"><pre>                [self assetFailedToPrepareForPlayback:playerItem.error];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayer "rate" property value observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (context == AVPlayerDemoPlaybackViewControllerRateObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayer "currentItem" property observer. <span></span></pre></td></tr><tr><td scope="row"><pre>        Called when the AVPlayer replaceCurrentItemWithPlayerItem: <span></span></pre></td></tr><tr><td scope="row"><pre>        replacement will/did occur. */<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (context == AVPlayerDemoPlaybackViewControllerCurrentItemObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        AVPlayerItem *newPlayerItem = [change objectForKey:NSKeyValueChangeNewKey];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Is the new player item null? */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (newPlayerItem == (id)[NSNull null])<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>            [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else /* Replacement of player currentItem has occurred */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Set the AVPlayer for which the player layer displays visual output. */<span></span></pre></td></tr><tr><td scope="row"><pre>            [self.mPlaybackView setPlayer:mPlayer];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            [self setViewDisplayName];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Specifies that the player should preserve the video’s aspect ratio and <span></span></pre></td></tr><tr><td scope="row"><pre>             fit the video within the layer’s bounds. */<span></span></pre></td></tr><tr><td scope="row"><pre>            [self.mPlaybackView setVideoFillMode:AVLayerVideoGravityResizeAspect];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [super observeValueForKeyPath:path ofObject:object change:change context:context];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div>

        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../History/History.html'>Next</a><a class='previousLink' rel='prev' href='Classes_AVPlayerDemoPlaybackViewController_h.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2013 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2013-06-07</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <input id="email" type="email" name="email" placeholder="Email (optional)" size="48">

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="../../../../../bug-reporting/index.html" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../Resources/874/JavaScript/lib/prototype.js"></script>
    <script src="../../../Resources/874/JavaScript/library.js"></script>
    <script src="../../../Resources/874/JavaScript/feedback.js"></script>
</body>
<script type="text/javascript" src="../../../../webstats/pagetracker.js"></script>
<script type="text/javascript">
if(typeof PageTracker !== 'undefined') {
  if(window.addEventListener) {
    window.addEventListener("load", function(){PageTracker.logPageLoad()},false);
  } else if(window.attachEvent) {
    window.attachEvent("onload",function(){PageTracker.logPageLoad()});
  }
}
</script>
</html>
