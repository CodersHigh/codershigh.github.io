<!DOCTYPE html>
<html lang="en">
<head>
    <title>StitchedStreamPlayer: Classes/MyStreamingMovieViewController.m</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Sample Code">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/DTS40010092">
	<meta id="document-version" name="document-version" content="2.0.0">
    <meta id="build" name="build" content="bcf073e0579478458b78c3b3068a2133">
    <meta id="chapterId" name="chapterId" content="DTS40010092-Classes_MyStreamingMovieViewController_m">
    <meta id="date" name="date" content="2011-06-27">
    <meta id="description" name="description" content="Using timed metadata to identify different content in a stream, supporting a custom seek UI, in AVFoundation.">
    <meta id="book-title" name="book-title" content="StitchedStreamPlayer">
    <meta id="book-name" name="book-name" content="DTS_SC2073_StitchedStreamPl">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="iOS Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/ios">
    <meta id="reflib" name="reflib" content="iOS Developer Library">
    <meta id="book-assignments" name="book-assignments" content="{Type/Sample Code}, {Framework/Media Layer/AVFoundation}, {Topic/Audio & Video}">
    
    
    <meta id="generator" name="generator" content="Gutenberg 003a3034">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2014 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Classes/MyStreamingMovieViewController.m">
    <meta id="resources-uri" name="resources-uri" content="../../../Resources/874">
    <link id="book-index-page" rel="Start" title="StitchedStreamPlayer" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../History/History.html">
    <link id="previous-page" rel="Prev" type="text/html" href="Classes_MyStreamingMovieViewController_h.html">
    <link rel="stylesheet" type="text/css" href="../../../Resources/874/CSS/screen.css">
    
    <link rel="stylesheet" type="text/css" href="../../../Resources/874/CSS/feedback.css">
</head>    
<body><a name="//apple_ref/doc/uid/DTS40010092-Classes_MyStreamingMovieViewController_m" title="Classes/MyStreamingMovieViewController.m"></a>
    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode phone">
            <a id="ssi_LibraryTitle" href='../../../navigation/index.html'>iOS Developer Library</a>
            <a id="ssi_AppleDeveloperConnection" href='../../../../../index.html'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search iOS Developer Library</label>
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>StitchedStreamPlayer</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../History/History.html'>Next</a><a class='previousLink' rel='prev' href='Classes_MyStreamingMovieViewController_h.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/DTS40010092-Classes_MyStreamingMovieViewController_m-DontLinkElementID_8" title="Classes/MyStreamingMovieViewController.m"></a>
    <h1 id="pageTitle">Classes/MyStreamingMovieViewController.m</h1>
    <div class="codesample clear"><table><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>    File: MyStreamingMovieViewController.m<span></span></pre></td></tr><tr><td scope="row"><pre>Abstract: <span></span></pre></td></tr><tr><td scope="row"><pre>A UIViewController controller subclass that loads the SecondView nib file that contains its view.<span></span></pre></td></tr><tr><td scope="row"><pre> Contains an action method that is called when the Play Movie button is pressed to play the movie.<span></span></pre></td></tr><tr><td scope="row"><pre> Provides a text edit control for the user to enter a movie URL.<span></span></pre></td></tr><tr><td scope="row"><pre> Manages a collection of transport control UI that allows the user to play/pause and seek.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> Version: 1.4<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple<span></span></pre></td></tr><tr><td scope="row"><pre>Inc. ("Apple") in consideration of your agreement to the following<span></span></pre></td></tr><tr><td scope="row"><pre>terms, and your use, installation, modification or redistribution of<span></span></pre></td></tr><tr><td scope="row"><pre>this Apple software constitutes acceptance of these terms.  If you do<span></span></pre></td></tr><tr><td scope="row"><pre>not agree with these terms, please do not use, install, modify or<span></span></pre></td></tr><tr><td scope="row"><pre>redistribute this Apple software.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>In consideration of your agreement to abide by the following terms, and<span></span></pre></td></tr><tr><td scope="row"><pre>subject to these terms, Apple grants you a personal, non-exclusive<span></span></pre></td></tr><tr><td scope="row"><pre>license, under Apple's copyrights in this original Apple software (the<span></span></pre></td></tr><tr><td scope="row"><pre>"Apple Software"), to use, reproduce, modify and redistribute the Apple<span></span></pre></td></tr><tr><td scope="row"><pre>Software, with or without modifications, in source and/or binary forms;<span></span></pre></td></tr><tr><td scope="row"><pre>provided that if you redistribute the Apple Software in its entirety and<span></span></pre></td></tr><tr><td scope="row"><pre>without modifications, you must retain this notice and the following<span></span></pre></td></tr><tr><td scope="row"><pre>text and disclaimers in all such redistributions of the Apple Software.<span></span></pre></td></tr><tr><td scope="row"><pre>Neither the name, trademarks, service marks or logos of Apple Inc. may<span></span></pre></td></tr><tr><td scope="row"><pre>be used to endorse or promote products derived from the Apple Software<span></span></pre></td></tr><tr><td scope="row"><pre>without specific prior written permission from Apple.  Except as<span></span></pre></td></tr><tr><td scope="row"><pre>expressly stated in this notice, no other rights or licenses, express or<span></span></pre></td></tr><tr><td scope="row"><pre>implied, are granted by Apple herein, including but not limited to any<span></span></pre></td></tr><tr><td scope="row"><pre>patent rights that may be infringed by your derivative works or by other<span></span></pre></td></tr><tr><td scope="row"><pre>works in which the Apple Software may be incorporated.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>The Apple Software is provided by Apple on an "AS IS" basis.  APPLE<span></span></pre></td></tr><tr><td scope="row"><pre>MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION<span></span></pre></td></tr><tr><td scope="row"><pre>THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS<span></span></pre></td></tr><tr><td scope="row"><pre>FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND<span></span></pre></td></tr><tr><td scope="row"><pre>OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL<span></span></pre></td></tr><tr><td scope="row"><pre>OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<span></span></pre></td></tr><tr><td scope="row"><pre>SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<span></span></pre></td></tr><tr><td scope="row"><pre>INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,<span></span></pre></td></tr><tr><td scope="row"><pre>MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED<span></span></pre></td></tr><tr><td scope="row"><pre>AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),<span></span></pre></td></tr><tr><td scope="row"><pre>STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE<span></span></pre></td></tr><tr><td scope="row"><pre>POSSIBILITY OF SUCH DAMAGE.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Copyright (C) 2011 Apple Inc. All Rights Reserved.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>*/<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#import "MyStreamingMovieViewController.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "MyPlayerLayerView.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;AVFoundation/AVFoundation.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void *MyStreamingMovieViewControllerTimedMetadataObserverContext = &amp;MyStreamingMovieViewControllerTimedMetadataObserverContext;<span></span></pre></td></tr><tr><td scope="row"><pre>static void *MyStreamingMovieViewControllerRateObservationContext = &amp;MyStreamingMovieViewControllerRateObservationContext;<span></span></pre></td></tr><tr><td scope="row"><pre>static void *MyStreamingMovieViewControllerCurrentItemObservationContext = &amp;MyStreamingMovieViewControllerCurrentItemObservationContext;<span></span></pre></td></tr><tr><td scope="row"><pre>static void *MyStreamingMovieViewControllerPlayerItemStatusObserverContext = &amp;MyStreamingMovieViewControllerPlayerItemStatusObserverContext;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kTracksKey        = @"tracks";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kStatusKey        = @"status";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kRateKey          = @"rate";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kPlayableKey      = @"playable";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kCurrentItemKey   = @"currentItem";<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *kTimedMetadataKey = @"currentItem.timedMetadata";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyStreamingMovieViewController (Player)<span></span></pre></td></tr><tr><td scope="row"><pre>- (CMTime)playerItemDuration;<span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isPlaying;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleTimedMetadata:(AVMetadataItem*)timedMetadata;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)updateAdList:(NSArray *)newAdList;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)assetFailedToPrepareForPlayback:(NSError *)error;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareToPlayAsset:(AVURLAsset *)asset withKeys:(NSArray *)requestedKeys;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyStreamingMovieViewController<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize movieURLTextField;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize movieTimeControl;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize playerLayerView;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize player, playerItem;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize isPlayingAdText;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize toolBar, playButton, stopButton;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Movie controller methods<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Methods to handle manipulation of the movie scrubber control<span></span></pre></td></tr><tr><td scope="row"><pre> ** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Play, Stop Buttons<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Show the stop button in the movie player controller. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)showStopButton<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *toolbarItems = [NSMutableArray arrayWithArray:[toolBar items]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [toolbarItems replaceObjectAtIndex:0 withObject:stopButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    toolBar.items = toolbarItems;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Show the play button in the movie player controller. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)showPlayButton<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *toolbarItems = [NSMutableArray arrayWithArray:[toolBar items]];<span></span></pre></td></tr><tr><td scope="row"><pre>    [toolbarItems replaceObjectAtIndex:0 withObject:playButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    toolBar.items = toolbarItems;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* If the media is playing, show the stop button; otherwise, show the play button. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncPlayPauseButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([self isPlaying])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showStopButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self showPlayButton];        <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)enablePlayerButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.playButton.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.stopButton.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)disablePlayerButtons<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.playButton.enabled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.stopButton.enabled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Scrubber control<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Set the scrubber based on the player current time. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)syncScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        movieTimeControl.minimumValue = 0.0;<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    } <span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isfinite(duration) &amp;&amp; (duration &gt; 0))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        float minValue = [movieTimeControl minimumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        float maxValue = [movieTimeControl maximumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        double time = CMTimeGetSeconds([player currentTime]);<span></span></pre></td></tr><tr><td scope="row"><pre>        [movieTimeControl setValue:(maxValue - minValue) * time / duration + minValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Requests invocation of a given block during media playback to update the <span></span></pre></td></tr><tr><td scope="row"><pre> movie scrubber control. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)initScrubberTimer<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    double interval = .1f;  <span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    } <span></span></pre></td></tr><tr><td scope="row"><pre>    double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGFloat width = CGRectGetWidth([movieTimeControl bounds]);<span></span></pre></td></tr><tr><td scope="row"><pre>        interval = 0.5f * duration / width;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Update the scrubber during normal playback. */<span></span></pre></td></tr><tr><td scope="row"><pre>    timeObserver = [[player addPeriodicTimeObserverForInterval:CMTimeMakeWithSeconds(interval, NSEC_PER_SEC) <span></span></pre></td></tr><tr><td scope="row"><pre>                                                          queue:NULL <span></span></pre></td></tr><tr><td scope="row"><pre>                                                     usingBlock:<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      ^(CMTime time) <span></span></pre></td></tr><tr><td scope="row"><pre>                                                      {<span></span></pre></td></tr><tr><td scope="row"><pre>                                                          [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      }] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Cancels the previously registered time observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>-(void)removePlayerTimeObserver<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (timeObserver)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [player removeTimeObserver:timeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>        [timeObserver release];<span></span></pre></td></tr><tr><td scope="row"><pre>        timeObserver = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The user is dragging the movie controller thumb to scrub through the movie. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)beginScrubbing:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    restoreAfterScrubbingRate = [player rate];<span></span></pre></td></tr><tr><td scope="row"><pre>    [player setRate:0.f];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Remove previous timer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* The user has released the movie thumb control to stop scrubbing through the movie. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)endScrubbing:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!timeObserver)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (CMTIME_IS_INVALID(playerDuration)) <span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        } <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            CGFloat width = CGRectGetWidth([movieTimeControl bounds]);<span></span></pre></td></tr><tr><td scope="row"><pre>            double tolerance = 0.5f * duration / width;<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            timeObserver = [[player addPeriodicTimeObserverForInterval:CMTimeMakeWithSeconds(tolerance, NSEC_PER_SEC) queue:dispatch_get_main_queue() usingBlock:<span></span></pre></td></tr><tr><td scope="row"><pre>                             ^(CMTime time)<span></span></pre></td></tr><tr><td scope="row"><pre>                             {<span></span></pre></td></tr><tr><td scope="row"><pre>                                 [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                             }] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    if (restoreAfterScrubbingRate)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [player setRate:restoreAfterScrubbingRate];<span></span></pre></td></tr><tr><td scope="row"><pre>        restoreAfterScrubbingRate = 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Set the player current time to match the scrubber position. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)scrub:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([sender isKindOfClass:[UISlider class]])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        UISlider* slider = sender;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        CMTime playerDuration = [self playerItemDuration];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (CMTIME_IS_INVALID(playerDuration)) {<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        } <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        double duration = CMTimeGetSeconds(playerDuration);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (isfinite(duration))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            float minValue = [slider minimumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>            float maxValue = [slider maximumValue];<span></span></pre></td></tr><tr><td scope="row"><pre>            float value = [slider value];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            double time = duration * (value - minValue) / (maxValue - minValue);<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            [player seekToTime:CMTimeMakeWithSeconds(time, NSEC_PER_SEC)];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isScrubbing<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return restoreAfterScrubbingRate != 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)enableScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.movieTimeControl.enabled = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)disableScrubber<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.movieTimeControl.enabled = NO;    <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Prevent the slider from seeking during Ad playback. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sliderSyncToPlayerSeekableTimeRanges<span></span></pre></td></tr><tr><td scope="row"><pre>{       <span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray *seekableTimeRanges = [[player currentItem] seekableTimeRanges];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([seekableTimeRanges count] &gt; 0) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSValue *range = [seekableTimeRanges objectAtIndex:0];<span></span></pre></td></tr><tr><td scope="row"><pre>        CMTimeRange timeRange = [range CMTimeRangeValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        float startSeconds = CMTimeGetSeconds(timeRange.start);<span></span></pre></td></tr><tr><td scope="row"><pre>        float durationSeconds = CMTimeGetSeconds(timeRange.duration);<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Set the minimum and maximum values of the time slider to match the seekable time range. */<span></span></pre></td></tr><tr><td scope="row"><pre>        movieTimeControl.minimumValue = startSeconds;<span></span></pre></td></tr><tr><td scope="row"><pre>        movieTimeControl.maximumValue = startSeconds + durationSeconds;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Button Action Methods<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)play:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* If we are at the end of the movie, we must seek to the beginning first <span></span></pre></td></tr><tr><td scope="row"><pre>     before starting playback. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (YES == seekToZeroBeforePlay) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        seekToZeroBeforePlay = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        [player seekToTime:kCMTimeZero];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [player play];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self showStopButton];  <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)pause:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [player pause];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [self showPlayButton];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)loadMovieButtonPressed:(id)sender<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Has the user entered a movie URL? */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self.movieURLTextField.text.length &gt; 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSURL *newMovieURL = [NSURL URLWithString:self.movieURLTextField.text];<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([newMovieURL scheme])   /* Sanity check on the URL. */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            /*<span></span></pre></td></tr><tr><td scope="row"><pre>             Create an asset for inspection of a resource referenced by a given URL.<span></span></pre></td></tr><tr><td scope="row"><pre>             Load the values for the asset keys "tracks", "playable".<span></span></pre></td></tr><tr><td scope="row"><pre>             */<span></span></pre></td></tr><tr><td scope="row"><pre>            AVURLAsset *asset = [AVURLAsset URLAssetWithURL:newMovieURL options:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            NSArray *requestedKeys = [NSArray arrayWithObjects:kTracksKey, kPlayableKey, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Tells the asset to load the values of any of the specified keys that are not already loaded. */<span></span></pre></td></tr><tr><td scope="row"><pre>            [asset loadValuesAsynchronouslyForKeys:requestedKeys completionHandler:<span></span></pre></td></tr><tr><td scope="row"><pre>             ^{      <span></span></pre></td></tr><tr><td scope="row"><pre>                 dispatch_async( dispatch_get_main_queue(), <span></span></pre></td></tr><tr><td scope="row"><pre>                                ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* IMPORTANT: Must dispatch to main queue in order to operate on the AVPlayer and AVPlayerItem. */<span></span></pre></td></tr><tr><td scope="row"><pre>                                    [self prepareToPlayAsset:asset withKeys:requestedKeys];<span></span></pre></td></tr><tr><td scope="row"><pre>                                });<span></span></pre></td></tr><tr><td scope="row"><pre>             }];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)textFieldShouldReturn:(UITextField *)theTextField <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* When the user presses return, take focus away from the text <span></span></pre></td></tr><tr><td scope="row"><pre>        field so that the keyboard is dismissed. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theTextField == self.movieURLTextField) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.movieURLTextField resignFirstResponder];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark View Controller<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewDidUnload<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self.playerLayerView = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.toolBar = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.playButton = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.stopButton = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.movieTimeControl = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.movieURLTextField = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.isPlayingAdText = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    [timeObserver release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [movieURL release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewDidUnload];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)viewDidLoad<span></span></pre></td></tr><tr><td scope="row"><pre>{    <span></span></pre></td></tr><tr><td scope="row"><pre>    UIView* view  = [self view];<span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizer* swipeUpRecognizer = [[UISwipeGestureRecognizer allocWithZone:[self zone]] initWithTarget:self action:@selector(handleSwipe:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeUpRecognizer setDirection:UISwipeGestureRecognizerDirectionUp];<span></span></pre></td></tr><tr><td scope="row"><pre>    [view addGestureRecognizer:swipeUpRecognizer];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeUpRecognizer release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizer* swipeDownRecognizer = [[UISwipeGestureRecognizer allocWithZone:[self zone]] initWithTarget:self action:@selector(handleSwipe:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeDownRecognizer setDirection:UISwipeGestureRecognizerDirectionDown];<span></span></pre></td></tr><tr><td scope="row"><pre>    [view addGestureRecognizer:swipeDownRecognizer];<span></span></pre></td></tr><tr><td scope="row"><pre>    [swipeDownRecognizer release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    UIBarButtonItem *scrubberItem = [[UIBarButtonItem alloc] initWithCustomView:movieTimeControl];<span></span></pre></td></tr><tr><td scope="row"><pre>    UIBarButtonItem *flexItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>    toolBar.items = [NSArray arrayWithObjects:playButton, flexItem, scrubberItem, nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [scrubberItem release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [flexItem release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super viewDidLoad];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Supports all orientations. */<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleSwipe:(UISwipeGestureRecognizer *)gestureRecognizer<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UIView* view = [self view];<span></span></pre></td></tr><tr><td scope="row"><pre>    UISwipeGestureRecognizerDirection direction = [gestureRecognizer direction];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPoint location = [gestureRecognizer locationInView:view];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    if (location.y &lt; CGRectGetMidY([view bounds]))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionUp)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>             ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                 [[self navigationController] setNavigationBarHidden:YES animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>             } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>             ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>             {<span></span></pre></td></tr><tr><td scope="row"><pre>                 [[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:UIStatusBarAnimationSlide];<span></span></pre></td></tr><tr><td scope="row"><pre>             }];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionDown)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>             ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                 [[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationSlide];<span></span></pre></td></tr><tr><td scope="row"><pre>             } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>             ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>             {<span></span></pre></td></tr><tr><td scope="row"><pre>                 [[self navigationController] setNavigationBarHidden:NO animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>             }];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (direction == UISwipeGestureRecognizerDirectionDown)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (![toolBar isHidden])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>                 ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                     [toolBar setTransform:CGAffineTransformMakeTranslation(0.f, CGRectGetHeight([toolBar bounds]))];<span></span></pre></td></tr><tr><td scope="row"><pre>                 } completion:<span></span></pre></td></tr><tr><td scope="row"><pre>                 ^(BOOL finished)<span></span></pre></td></tr><tr><td scope="row"><pre>                 {<span></span></pre></td></tr><tr><td scope="row"><pre>                     [toolBar setHidden:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>                 }];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else if (direction == UISwipeGestureRecognizerDirectionUp)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            if ([toolBar isHidden])<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [toolBar setHidden:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [UIView animateWithDuration:0.2f animations:<span></span></pre></td></tr><tr><td scope="row"><pre>                 ^{<span></span></pre></td></tr><tr><td scope="row"><pre>                     [toolBar setTransform:CGAffineTransformIdentity];<span></span></pre></td></tr><tr><td scope="row"><pre>                 } completion:^(BOOL finished){}];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [timeObserver release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [movieURL release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] removeObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    name:AVPlayerItemDidPlayToEndTimeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  object:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.player removeObserver:self forKeyPath:kCurrentItemKey];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.player removeObserver:self forKeyPath:kTimedMetadataKey];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.player removeObserver:self forKeyPath:kRateKey];<span></span></pre></td></tr><tr><td scope="row"><pre>    [player release]; <span></span></pre></td></tr><tr><td scope="row"><pre>    [adList release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [movieURLTextField release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [movieTimeControl release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [playerLayerView release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [toolBar release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [playButton release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [stopButton release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [isPlayingAdText release];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyStreamingMovieViewController (Player)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Player<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Get the duration for a AVPlayerItem. <span></span></pre></td></tr><tr><td scope="row"><pre> ** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (CMTime)playerItemDuration<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    AVPlayerItem *thePlayerItem = [player currentItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (thePlayerItem.status == AVPlayerItemStatusReadyToPlay)<span></span></pre></td></tr><tr><td scope="row"><pre>    {        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* <span></span></pre></td></tr><tr><td scope="row"><pre>         NOTE:<span></span></pre></td></tr><tr><td scope="row"><pre>         Because of the dynamic nature of HTTP Live Streaming Media, the best practice <span></span></pre></td></tr><tr><td scope="row"><pre>         for obtaining the duration of an AVPlayerItem object has changed in iOS 4.3. <span></span></pre></td></tr><tr><td scope="row"><pre>         Prior to iOS 4.3, you would obtain the duration of a player item by fetching <span></span></pre></td></tr><tr><td scope="row"><pre>         the value of the duration property of its associated AVAsset object. However, <span></span></pre></td></tr><tr><td scope="row"><pre>         note that for HTTP Live Streaming Media the duration of a player item during <span></span></pre></td></tr><tr><td scope="row"><pre>         any particular playback session may differ from the duration of its asset. For <span></span></pre></td></tr><tr><td scope="row"><pre>         this reason a new key-value observable duration property has been defined on <span></span></pre></td></tr><tr><td scope="row"><pre>         AVPlayerItem.<span></span></pre></td></tr><tr><td scope="row"><pre>         <span></span></pre></td></tr><tr><td scope="row"><pre>         See the AV Foundation Release Notes for iOS 4.3 for more information.<span></span></pre></td></tr><tr><td scope="row"><pre>         */     <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        return([playerItem duration]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return(kCMTimeInvalid);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (BOOL)isPlaying<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return restoreAfterScrubbingRate != 0.f || [player rate] != 0.f;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Player Notifications<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Called when the player item has played to its end time. */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void) playerItemDidReachEnd:(NSNotification*) aNotification <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Hide the 'Pause' button, show the 'Play' button in the slider control */<span></span></pre></td></tr><tr><td scope="row"><pre>    [self showPlayButton];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* After the movie has played to its end time, seek back to time zero <span></span></pre></td></tr><tr><td scope="row"><pre>     to play it again */<span></span></pre></td></tr><tr><td scope="row"><pre>    seekToZeroBeforePlay = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Timed metadata<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handleTimedMetadata:(AVMetadataItem*)timedMetadata<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* We expect the content to contain plists encoded as timed metadata. AVPlayer turns these into NSDictionaries. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([(NSString *)[timedMetadata key] isEqualToString:AVMetadataID3MetadataKeyGeneralEncapsulatedObject]) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([[timedMetadata value] isKindOfClass:[NSDictionary class]]) <span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            NSDictionary *propertyList = (NSDictionary *)[timedMetadata value];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Metadata payload could be the list of ads. */<span></span></pre></td></tr><tr><td scope="row"><pre>            NSArray *newAdList = [propertyList objectForKey:@"ad-list"];<span></span></pre></td></tr><tr><td scope="row"><pre>            if (newAdList != nil) <span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self updateAdList:newAdList];<span></span></pre></td></tr><tr><td scope="row"><pre>                NSLog(@"ad-list is %@", newAdList);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Or it might be an ad record. */<span></span></pre></td></tr><tr><td scope="row"><pre>            NSString *adURL = [propertyList objectForKey:@"url"];<span></span></pre></td></tr><tr><td scope="row"><pre>            if (adURL != nil) <span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                if ([adURL isEqualToString:@""]) <span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    /* Ad is not playing, so clear text. */<span></span></pre></td></tr><tr><td scope="row"><pre>                    self.isPlayingAdText.text = @"";<span></span></pre></td></tr><tr><td scope="row"><pre>                    <span></span></pre></td></tr><tr><td scope="row"><pre>                    [self enablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self enableScrubber]; /* Enable seeking for main content. */<span></span></pre></td></tr><tr><td scope="row"><pre>                    <span></span></pre></td></tr><tr><td scope="row"><pre>                    NSLog(@"enabling seek at %g", CMTimeGetSeconds([player currentTime]));<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else <span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    /* Display text indicating that an Ad is now playing. */<span></span></pre></td></tr><tr><td scope="row"><pre>                    self.isPlayingAdText.text = @"&lt; Ad now playing, seeking is disabled on the movie controller... &gt;";<span></span></pre></td></tr><tr><td scope="row"><pre>                    <span></span></pre></td></tr><tr><td scope="row"><pre>                    [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>                    [self disableScrubber];     /* Disable seeking for ad content. */<span></span></pre></td></tr><tr><td scope="row"><pre>                    <span></span></pre></td></tr><tr><td scope="row"><pre>                    NSLog(@"disabling seek at %g", CMTimeGetSeconds([player currentTime]));<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Ad list<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Update current ad list, set slider to match current player item seekable time ranges */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)updateAdList:(NSArray *)newAdList<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!adList || ![adList isEqualToArray:newAdList]) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        newAdList = [newAdList copy];<span></span></pre></td></tr><tr><td scope="row"><pre>        [adList release];<span></span></pre></td></tr><tr><td scope="row"><pre>        adList = newAdList;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self sliderSyncToPlayerSeekableTimeRanges];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}   <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Loading the Asset Keys Asynchronously<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Error Handling - Preparing Assets for Playback Failed<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* --------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Called when an asset fails to prepare for playback for any of<span></span></pre></td></tr><tr><td scope="row"><pre> **  the following reasons:<span></span></pre></td></tr><tr><td scope="row"><pre> ** <span></span></pre></td></tr><tr><td scope="row"><pre> **  1) values of asset keys did not load successfully, <span></span></pre></td></tr><tr><td scope="row"><pre> **  2) the asset keys did load successfully, but the asset is not <span></span></pre></td></tr><tr><td scope="row"><pre> **     playable<span></span></pre></td></tr><tr><td scope="row"><pre> **  3) the item did not become ready to play. <span></span></pre></td></tr><tr><td scope="row"><pre> ** ----------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>-(void)assetFailedToPrepareForPlayback:(NSError *)error<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Display the error. */<span></span></pre></td></tr><tr><td scope="row"><pre>    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:[error localizedDescription]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        message:[error localizedFailureReason]<span></span></pre></td></tr><tr><td scope="row"><pre>                                                       delegate:nil<span></span></pre></td></tr><tr><td scope="row"><pre>                                              cancelButtonTitle:@"OK"<span></span></pre></td></tr><tr><td scope="row"><pre>                                              otherButtonTitles:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [alertView show];<span></span></pre></td></tr><tr><td scope="row"><pre>    [alertView release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Prepare to play asset<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre> Invoked at the completion of the loading of the values for all keys on the asset that we require.<span></span></pre></td></tr><tr><td scope="row"><pre> Checks whether loading was successfull and whether the asset is playable.<span></span></pre></td></tr><tr><td scope="row"><pre> If so, sets up an AVPlayerItem and an AVPlayer to play the asset.<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)prepareToPlayAsset:(AVURLAsset *)asset withKeys:(NSArray *)requestedKeys<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make sure that the value of each key has loaded successfully. */<span></span></pre></td></tr><tr><td scope="row"><pre>    for (NSString *thisKey in requestedKeys)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSError *error = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        AVKeyValueStatus keyStatus = [asset statusOfValueForKey:thisKey error:&amp;error];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (keyStatus == AVKeyValueStatusFailed)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self assetFailedToPrepareForPlayback:error];<span></span></pre></td></tr><tr><td scope="row"><pre>            return;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        /* If you are also implementing the use of -[AVAsset cancelLoading], add your code here to bail <span></span></pre></td></tr><tr><td scope="row"><pre>         out properly in the case of cancellation. */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Use the AVAsset playable property to detect whether the asset can be played. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!asset.playable) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Generate an error describing the failure. */<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *localizedDescription = NSLocalizedString(@"Item cannot be played", @"Item cannot be played description");<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *localizedFailureReason = NSLocalizedString(@"The assets tracks were loaded, but could not be made playable.", @"Item cannot be played failure reason");<span></span></pre></td></tr><tr><td scope="row"><pre>        NSDictionary *errorDict = [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>                                   localizedDescription, NSLocalizedDescriptionKey, <span></span></pre></td></tr><tr><td scope="row"><pre>                                   localizedFailureReason, NSLocalizedFailureReasonErrorKey, <span></span></pre></td></tr><tr><td scope="row"><pre>                                   nil];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSError *assetCannotBePlayedError = [NSError errorWithDomain:@"StitchedStreamPlayer" code:0 userInfo:errorDict];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Display the error to the user. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self assetFailedToPrepareForPlayback:assetCannotBePlayedError];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* At this point we're ready to set up for playback of the asset. */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [self initScrubberTimer];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self enableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self enablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Stop observing our prior AVPlayerItem, if we have one. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self.playerItem)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Remove existing player item key value observers and notifications. */<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self.playerItem removeObserver:self forKeyPath:kStatusKey];            <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [[NSNotificationCenter defaultCenter] removeObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                                        name:AVPlayerItemDidPlayToEndTimeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                                      object:self.playerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create a new instance of AVPlayerItem from the now successfully loaded AVAsset. */<span></span></pre></td></tr><tr><td scope="row"><pre>    self.playerItem = [AVPlayerItem playerItemWithAsset:asset];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Observe the player item "status" key to determine when it is ready to play. */<span></span></pre></td></tr><tr><td scope="row"><pre>    [self.playerItem addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kStatusKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:MyStreamingMovieViewControllerPlayerItemStatusObserverContext];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* When the player item has played to its end time we'll toggle<span></span></pre></td></tr><tr><td scope="row"><pre>     the movie controller Pause button to be the Play button */<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                             selector:@selector(playerItemDidReachEnd:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                                 name:AVPlayerItemDidPlayToEndTimeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                               object:self.playerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    seekToZeroBeforePlay = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create new player, if we don't already have one. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![self player])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Get a new AVPlayer initialized to play the specified player item. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPlayer:[AVPlayer playerWithPlayerItem:self.playerItem]];   <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Observe the AVPlayer "currentItem" property to find out when any <span></span></pre></td></tr><tr><td scope="row"><pre>         AVPlayer replaceCurrentItemWithPlayerItem: replacement will/did <span></span></pre></td></tr><tr><td scope="row"><pre>         occur.*/<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.player addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kCurrentItemKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:MyStreamingMovieViewControllerCurrentItemObservationContext];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* A 'currentItem.timedMetadata' property observer to parse the media stream timed metadata. */         <span></span></pre></td></tr><tr><td scope="row"><pre>        [self.player addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kTimedMetadataKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:0 <span></span></pre></td></tr><tr><td scope="row"><pre>                         context:MyStreamingMovieViewControllerTimedMetadataObserverContext];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* Observe the AVPlayer "rate" property to update the scrubber control. */<span></span></pre></td></tr><tr><td scope="row"><pre>        [self.player addObserver:self <span></span></pre></td></tr><tr><td scope="row"><pre>                      forKeyPath:kRateKey <span></span></pre></td></tr><tr><td scope="row"><pre>                         options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew<span></span></pre></td></tr><tr><td scope="row"><pre>                         context:MyStreamingMovieViewControllerRateObservationContext];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Make our new AVPlayerItem the AVPlayer's current item. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self.player.currentItem != self.playerItem)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Replace the player item with a new player item. The item replacement occurs <span></span></pre></td></tr><tr><td scope="row"><pre>         asynchronously; observe the currentItem property to find out when the <span></span></pre></td></tr><tr><td scope="row"><pre>         replacement will/did occur*/<span></span></pre></td></tr><tr><td scope="row"><pre>        [[self player] replaceCurrentItemWithPlayerItem:self.playerItem];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    [movieTimeControl setValue:0.0];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark -<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Asset Key Value Observing<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark Key Value Observer for player rate, currentItem, player item status<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* ---------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre> **  Called when the value at the specified key path relative<span></span></pre></td></tr><tr><td scope="row"><pre> **  to the given object has changed. <span></span></pre></td></tr><tr><td scope="row"><pre> **  Adjust the movie play and pause button controls when the <span></span></pre></td></tr><tr><td scope="row"><pre> **  player item "status" value changes. Update the movie <span></span></pre></td></tr><tr><td scope="row"><pre> **  scrubber control when the player item is ready to play.<span></span></pre></td></tr><tr><td scope="row"><pre> **  Adjust the movie scrubber control when the player item <span></span></pre></td></tr><tr><td scope="row"><pre> **  "rate" value changes. For updates of the player<span></span></pre></td></tr><tr><td scope="row"><pre> **  "currentItem" property, set the AVPlayer for which the <span></span></pre></td></tr><tr><td scope="row"><pre> **  player layer displays visual output.<span></span></pre></td></tr><tr><td scope="row"><pre> **  NOTE: this method is invoked on the main queue.<span></span></pre></td></tr><tr><td scope="row"><pre> ** ------------------------------------------------------- */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)observeValueForKeyPath:(NSString*) path <span></span></pre></td></tr><tr><td scope="row"><pre>                      ofObject:(id)object <span></span></pre></td></tr><tr><td scope="row"><pre>                        change:(NSDictionary*)change <span></span></pre></td></tr><tr><td scope="row"><pre>                       context:(void*)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayerItem "status" property value observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (context == MyStreamingMovieViewControllerPlayerItemStatusObserverContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        AVPlayerStatus status = [[change objectForKey:NSKeyValueChangeNewKey] integerValue];<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (status)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Indicates that the status of the player is not yet known because <span></span></pre></td></tr><tr><td scope="row"><pre>                 it has not tried to load new media resources for playback */<span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusUnknown:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                [self removePlayerTimeObserver];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self syncScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusReadyToPlay:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* Once the AVPlayerItem becomes ready to play, i.e. <span></span></pre></td></tr><tr><td scope="row"><pre>                 [playerItem status] == AVPlayerItemStatusReadyToPlay,<span></span></pre></td></tr><tr><td scope="row"><pre>                 its duration can be fetched from the item. */<span></span></pre></td></tr><tr><td scope="row"><pre>                                <span></span></pre></td></tr><tr><td scope="row"><pre>                playerLayerView.playerLayer.hidden = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [toolBar setHidden:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                /* Show the movie slider control since the movie is now ready to play. */<span></span></pre></td></tr><tr><td scope="row"><pre>                movieTimeControl.hidden = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                [self enableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>                [self enablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                playerLayerView.playerLayer.backgroundColor = [[UIColor blackColor] CGColor];<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                /* Set the AVPlayerLayer on the view to allow the AVPlayer object to display<span></span></pre></td></tr><tr><td scope="row"><pre>                 its content. */    <span></span></pre></td></tr><tr><td scope="row"><pre>                [playerLayerView.playerLayer setPlayer:player];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                [self initScrubberTimer];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>            case AVPlayerStatusFailed:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                AVPlayerItem *thePlayerItem = (AVPlayerItem *)object;<span></span></pre></td></tr><tr><td scope="row"><pre>                [self assetFailedToPrepareForPlayback:thePlayerItem.error];<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayer "rate" property value observer. */<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (context == MyStreamingMovieViewControllerRateObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* AVPlayer "currentItem" property observer. <span></span></pre></td></tr><tr><td scope="row"><pre>     Called when the AVPlayer replaceCurrentItemWithPlayerItem: <span></span></pre></td></tr><tr><td scope="row"><pre>     replacement will/did occur. */<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (context == MyStreamingMovieViewControllerCurrentItemObservationContext)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        AVPlayerItem *newPlayerItem = [change objectForKey:NSKeyValueChangeNewKey];<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        /* New player item null? */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (newPlayerItem == (id)[NSNull null])<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self disablePlayerButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>            [self disableScrubber];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            self.isPlayingAdText.text = @"";<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else /* Replacement of player currentItem has occurred */<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            /* Set the AVPlayer for which the player layer displays visual output. */<span></span></pre></td></tr><tr><td scope="row"><pre>            [playerLayerView.playerLayer setPlayer:self.player];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            /* Specifies that the player should preserve the video’s aspect ratio and <span></span></pre></td></tr><tr><td scope="row"><pre>             fit the video within the layer’s bounds. */<span></span></pre></td></tr><tr><td scope="row"><pre>            [playerLayerView setVideoFillMode:AVLayerVideoGravityResizeAspect];<span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            [self syncPlayPauseButtons];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Observe the AVPlayer "currentItem.timedMetadata" property to parse the media stream <span></span></pre></td></tr><tr><td scope="row"><pre>     timed metadata. */<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (context == MyStreamingMovieViewControllerTimedMetadataObserverContext) <span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSArray* array = [[player currentItem] timedMetadata];<span></span></pre></td></tr><tr><td scope="row"><pre>        for (AVMetadataItem *metadataItem in array) <span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [self handleTimedMetadata:metadataItem];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [super observeValueForKeyPath:path ofObject:object change:change context:context];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div>

        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../History/History.html'>Next</a><a class='previousLink' rel='prev' href='Classes_MyStreamingMovieViewController_h.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2011 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2011-06-27</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <input id="email" type="email" name="email" placeholder="Email (optional)" size="48">

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="../../../../../bug-reporting/index.html" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../Resources/874/JavaScript/lib/prototype.js"></script>
    <script src="../../../Resources/874/JavaScript/library.js"></script>
    <script src="../../../Resources/874/JavaScript/feedback.js"></script>
</body>
<script type="text/javascript" src="../../../../webstats/pagetracker.js"></script>
<script type="text/javascript">
if(typeof PageTracker !== 'undefined') {
  if(window.addEventListener) {
    window.addEventListener("load", function(){PageTracker.logPageLoad()},false);
  } else if(window.attachEvent) {
    window.attachEvent("onload",function(){PageTracker.logPageLoad()});
  }
}
</script>
</html>
